---
title: "Power/sample size
various endpoints v0.0.1" 
author: 
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    social: menu
    source_code: embed
runtime: shiny
---
 
 
 
 
```{r global, include=FALSE}

  rm(list=ls())
  set.seed(6453)
  library(ggplot2)
  library(tidyverse)
  library(plotly)
  library(Hmisc)
  require(data.table)
  library(rms) # for PO regression
 
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # function to format decimals
  # https://stackoverflow.com/questions/3245862/format-numbers-to-significant-figures-nicely-in-r
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  formatz <- function(x){
    
    if (!is.na(x)  ) {
      
      formatC(signif(x,digits=5), digits=5,format="fg", flag="#",big.mark=",")
      
    }
    
  }
  
  formatz0 <- function(x){
    sprintf(x, fmt = '%s')  
  }
  formatz1 <- function(x){
    sprintf(x, fmt = '%#.1f')  
  }
  formatz2 <- function(x){
    sprintf(x, fmt = '%#.2f')  
  }
  formatz00 <- function(x){
    round(x,0) 
  }
  formatz3 <- function(x){
    sprintf(x, fmt = '%#.3f')  
  }
  formatz4 <- function(x){
    sprintf(x, fmt = '%#.4f')  
  }
  
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# start of app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  


``` 

Continuous
====
 

Column {.sidebar}
-----------------------------------------------------------------------


**Enter parameters of interest separated by a comma**

```{r}

 
  
          splitLayout(
          textInput("mu1x",    
                    div(h5(tags$span(style="color:blue", "\U1D77B 1, enter pop. means"))),    
          value= "2"),)
           

          splitLayout(
          textInput("sd1x",    
                    div(h5(tags$span(style="color:blue", "\U1D7BC 1, enter pop. SDs"))),    
          value= "3"),)
          
          
          splitLayout(
          textInput("mu2x",    
                    div(h5(tags$span(style="color:blue", "\U1D77B 2, enter pop. means"))),    
          value= "3"),)
                 
                 
                        splitLayout(
          textInput("rsdx",    
                    div(h5(tags$span(style="color:blue", "ratio for unequal \U1D7BCs "))),   
          value= "1"),)                                
               
          splitLayout(
          textInput("alphamx", 
                     div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= ".05"),  )
              
              
          splitLayout(
          textInput("sidemx",
                    div(h5(tags$span(style="color:blue", "one or two sided alternative?"))),
          value= "2, 1"),)
              
          splitLayout(
          textInput("romx",    
                    div(h5(tags$span(style="color:blue", "ratio for unequal randomisation"))),   
          value= "1,2"),)     
                    
       

                                        
          sliderInput('x_r', 'Plot x-range', value = c(0,400),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_r', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

   
          br()
       
                
s22 <- reactive({
  
# function adapted from gsDesign::nEvents--------------------------------------------------------------------------
  
    A <-   (as.numeric(unlist(strsplit(input$alphamx,","))))    #alpha

    Az <-   (as.numeric(unlist(strsplit(input$mu1x,","))))    # mean1
    
    Aa<-   (as.numeric(unlist(strsplit(input$sd1x,","))))    # sd
    
    m2 <-   (as.numeric(unlist(strsplit(input$mu2x,","))))    # mean 2

    Ac<-   (as.numeric(unlist(strsplit(input$sidemx,","))))  # one or two sided

    Ab<-   (as.numeric(unlist(strsplit(input$romx,","))))    # randomisation
    
    Ad<-   (as.numeric(unlist(strsplit(input$rsdx,","))))    # sd ratio

    n= seq(2,input$x_r[2], 2)
      
      
      
# hard code for testing
    #  n <- seq(2,200,2)
# Az <-  c(1,2)   # mean 1
# m2 <-   c(2,3)  # mean2
# A <-   c(.05,.025)   # alpha
# Aa<-   c(2,2)    # rand ratio
# Ab<-   c(1,2)   #sd ratio and rand ratio
# Ac<-   c(1,2) # ssigma 

      
      
  side <- ifelse(Ac==1,"one.sided", ifelse(Ac==2,"two.sided", NA))
  
 
  
  d <- tidyr::expand_grid(mu1 = Az, mu2=m2, alpha=A, ratio =Ab, n=n,  sd=Aa, side=side, sd.ratio=Ad)
  
  bvout <- matrix(NA, ncol=10, nrow=dim(d)[1])
  bvout <- as.data.frame(bvout)

#apply function to each row    

  for( i in 1: dim(d)[1]) {
    
    # circumventing weird results as function need mu order fro 1 side
    if (d$side[i] %in% "one.sided") {
      
     z <-  MESS::power_t_test(n=d$n[i], sd=d$sd[i], power=NULL, ratio=d$ratio[i], sd.ratio=d$sd.ratio[i], 
                             delta=d$mu2[i]-d$mu1[i], 
                                          alternative=d$side[i],
                                          sig.level=d$alpha[i])
    } else {
     
     z <-  MESS::power_t_test(n=d$n[i], sd=d$sd[i], power=NULL, ratio=d$ratio[i], sd.ratio=d$sd.ratio[i], 
                             delta=d$mu1[i]-d$mu2[i], 
                                          alternative=d$side[i],
                                          sig.level=d$alpha[i])
    
    }
    
    x <- unlist(z)
    
   
    if (length(x) < 10) {x <- c(x[1], NA, x[2:3], NA , x[4:8]) }  #pad when sd ratio and rand ratio change
    
    
    bvout[i,] <- x
  }

   # fill NA 
  bvout[] <- t(apply(bvout, 1, zoo::na.locf))
  
   
  names(bvout)  <-c("n1", "n2", "delta",  "sigma1", "sigma2", "alpha", "power", "side", "n note" , "note")
  
  bvout$n <- as.numeric(bvout$n1) + as.numeric(bvout$n2)
  bvout$power <- as.numeric(bvout$power)
  
  result <- cbind(bvout, d)

 
################text


  x <- result
  
  txt <- with(x,paste0("~\U1D728( ",mu1,", ",sigma2,")", 
                       " & ~\U1D728( ",mu2,", ",sigma2,")", 
                       "\n\U1D7AA= ",alpha, " ",side, ", \nrandomisation ratio=",ratio,"\n"))
  
  
  x$phrase <- txt
  
  x$ratio <- ifelse(x$n2==x$n1, "equal","unequal")
  
    
  
  pow <- x[,c("n","power","phrase","ratio")]
   
     
  #-----------------------------------------------------------------------
  return(list(  
      
      pow=pow
      
     ))    

})
      

```
 
 
## Column {.tabset .tabset-fade}

### Chart 1

```{r surv plot9, eval=TRUE}

 
renderPlot({
  
 L =      s22()$pow
 
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_r[2] <= 1000, 50,
           ifelse(input$x_r[2] > 1000 & input$x_r[2] < 3000 ,200
                       ,  500))

 
  all <- ggplot(data=L,
       aes(x=n, y=power, 
           colour=phrase)) +
  geom_line()  +
 
  scale_y_continuous(breaks = 
                       seq(input$y_r [1], input$y_r [2], by = 0.1),
                       limits = c(input$y_r [1], input$y_r [2])) +
    
  scale_x_continuous(breaks =
                       seq(input$x_r [1], input$x_r [2], skips), 
                       limits = c(input$x_r [1],  input$x_r [2])) +
    
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +

  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Total Sample Size', color = "Scenario")+
 
  labs(caption = paste("- Alpha the type I assertion probability." )) +

  ggtitle(paste0(" Power (or total sample size) ") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
 
 })


 
```

### Wiki

 

```{r surv wiki}
 
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
 
  
```

Ordinal
===

```{r}
 
```

Column {.sidebar}
-----------------------------------------------------------------------

**With ordinal data, under proportional odds, the overall probability of each category is required. Enter cell probabilities of interest separated by a comma. Must sum to 1**

```{r tabn}

          splitLayout(
          textInput("p1",    div(h5(tags$span(style="color:blue", "\U1D7B9 1..n"))),    
          value= ".222,.323,.455"),)
      
 #"0.044, 0.019, 0.471, 0.317, 0.149"     


          splitLayout(
          textInput("or", div(h5(tags$span(style="color:blue", "odds ratios"))), 
          value= "1.840431"),       )
          
          splitLayout(
          textInput("alpha", div(h5(tags$span(style="color:blue", "\U1D7AA (type I errors two-sided)"))), 
          value= "0.025, 0.05"),    )
                                         
          splitLayout(
          textInput("Q", div(h5(tags$span(style="color:blue", "ratios for unequal randomisation \n (1 for equal randomisation)"))),   
          value= "0.5, 1"),)                                
                                        
          sliderInput('x_rangepo', 'Plot x-range', value = c(0,800),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_rangepo', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

   
          br()

 #          div(h5(tags$span(style="color:blue", "Most sample size formulae involve nuisance parameters, the values of which are unknown
 # when the trial is designed. With ordinal data, under proportional odds, it is the overall probability of each category that is required. For data of this type, with no allowance for prognostic variables, use of the proportional odds regression
 # model is equivalent to the Wilcoxon rank sum test (Mann Whitney test). The above example [Whitehead, 1983], has an expected placebo distribution 0.17, 0.30, 0.53 and a treatment outcome distribution of 0.274, 0346, 0.38, a log odds ratio 0.61. We enter p1 as (0.17+0.274)/2 = 0.222 etc.")))
      
             
          
 por <- reactive({
  
 A <-   sig.level <-   (as.numeric(unlist(strsplit(input$alpha,","))))    
        P         <-   (as.numeric(unlist(strsplit(input$p1,","))))    
        Q         <-   (as.numeric(unlist(strsplit(input$Q,"," ))))    # fraction
        or        <-   (as.numeric(unlist(strsplit(input$or,","))))   
    
 # A <- c(.025,.05)
 # P=c(.2,.3,.5)
 #        Q=1
 #        or=c(2,3)
        
        n= seq(2,input$x_rangepo[2], 2)

        d <- tidyr::expand_grid(or = or, alpha=A, frac =Q, n=n)
       
        d$n1 <- round(d$n*d$frac/(d$frac+1))
        
        d$n2 <- d$n - d$n1 
        
        res <-  Hmisc::popower(p=P, odds.ratio=d$or,  n1=d$n1, n2=d$n2, alpha=d$alpha)
       
        result <- cbind(unlist(res[1][[1]]), unlist(res[2][[1]]), unlist(res[3][[1]]), d)
        
        names(result)  <- c("power","eff","approx se","or",  "alpha" ,"frac","n","n1","n2" )
       
        ##--txt for legend
        x <- result
           
        txt <- with(x,paste0("OR=",or,", alpha ",alpha, ", \nratio=",frac))
 
        x$phrase <- txt
      
        x$tag <- as.character(x$phrase)
      
        result=x
 
 
    return(list(  
       
       result=result, P=P, or=or
       
      ))    
 
 })
       
  

```
 
 
## Column {.tabset .tabset-fade}

### Chart 2

```{r surv plot4, eval=TRUE}


renderPlot({
  
 p =      por()$result
  
 p <- p[complete.cases(p), ]
 
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_rangepo[2] <= 1000, 50,
           ifelse(input$x_rangepo[2] > 1000 & input$x_rangepo[2] < 3000 ,200
                       ,  500))
 

   p <- p[,c(  "n" , "alpha",   "power",   "frac", "or" ,"tag")]
   names(p)  <-    c( "n" , "alpha",   "power",   "ratio", "variable", "tag")
  #-----------------------------------------------------------------------
   
   p <- as.data.frame(p)
   p$ratio <- factor(p$ratio)
   p$variable <- factor(p$variable)
  
  all <- ggplot(p, aes(x = n, y = power, 
                
                    group = interaction(ratio, variable, alpha),
                     
                    colour = tag)) +  
  geom_line() +
 
  scale_y_continuous(breaks = 
                       seq(input$y_rangepo[1], input$y_rangepo[2], by = 0.1),
                       limits = c(input$y_rangepo[1], input$y_rangepo[2])) +
    
  scale_x_continuous(breaks =
                       seq(input$x_rangepo[1], input$x_rangepo[2], skips), 
                       limits = c(input$x_rangepo[1],  input$x_rangepo[2])) +
    
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +


  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Total Sample Size', color = "Scenario", linetype="Ratio" )+
 
  labs(caption = paste("- Alpha the type I assertion probability. \n- The allocation ratio affects the second group. \n- Can use to power non-inferiority design, recall alpha 0.025 one sided is the same as 0.05 two sided. \n- Uses Hmisc::popower to compute the power for a two-tailed two sample comparison of ordinal outcomes under the proportional odds ordinal logistic model. \n- For the randomisation allocation, 1 is equal to 1:1 randomisation. If 0.33 is entered for unequal randomisation, 75% of patients are randomised to the treatment arm.\n- The validity of the sample size calculation above depends on three assumptions. First, that the proportional odds model is at least approximately valid. Second, that the nuisance parameters involved in equation, namely the proportions of patients in each of the categories on placebo, \nare at least approximately as expected. Third, that none of the prognostic factors recorded at baseline have a major impact on the outcome measure. If any of these assumptions do not hold then the sample size calculated will not be valid, and the trial may not achieve its target power." )) +

  ggtitle(paste0("Proportional odds, power (or total sample size) for ordinal catergorical data (superiority and non-inferiority)") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
#-----------------------------------------------------------
#ggplotly(all)
 })
 
### Column {.tabset .tabset-fade} <- this will split page in two
```



### Wiki

 
```{r po wiki, eval=TRUE}

h5(htmlOutput("powiki")) 
br()
 h5(htmlOutput("powiki2")) 

 
#-------------------------------------------------------------------------------------------------------

  output$powiki2 <- renderText({
    text <- "Click here to visit Whitehead, 1988"
    link <- "<a href='https://github.com/eamonn2014/power/blob/main/papers%20for%20git/Whitehead%201998%20sample%20size%20review%20in%20a%20head%20injury%20trial.pdf', target='_self', >Whitehead 1988</a>"
    paste0(text, " ", link)
  })



 output$powiki <- renderText({  # create interactive text t1
 
   
print(paste0(   
   
   tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
        
                 "Most sample size formulae involve nuisance parameters, the values of which are unknown when the trial is designed. With ordinal data, under proportional odds, it is the overall probability of each category that is required. For data of this type, with no allowance for prognostic variables, use of the proportional odds regression model is equivalent to the Wilcoxon rank sum test (Mann Whitney test). We use the example in Whitehead, 1988, which has an expected placebo distribution 0.17, 0.30, 0.53 and a treatment outcome distribution of 0.274, 0346, 0.38, a log odds ratio 0.61. We enter the reference proportion as (0.17 + 0.274)/2 = 0.222 etc."),
     
   
           br(),  br(), 
       
          tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
                 
                 "Proportional odds (PO) and ordinal logisitc regression are synonyms. Frank Harrell's Hmisc::lrm function is used in this app, the parameterisation is pr[Y >= j|X]. When Y=0,1, the parameterisation is exactly that for binary logistic regression. This may be different to other PO model functions. For example, the PASS power sample software's procedure 'Tests for Two Ordered Categorical Variables' uses the opposite parameterisation, so an odds ratio of say 3/2 in this app is equivalent to and odds ratio of 2/3 with that software and vice versa. If we consider higher categories as worse outcomes, the default 1.7 odds ratio, indicates that the treatment relative to  placebo in truth is associated with a 1.70 times increased odds of having a more serious outcome.") ,
  
        br(),  br(), 
       
         tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
                 
                 "With the PO model, every category can even have only 1 entry. The WRST test works best when there are no ties (P values are more accurate). The PO model also works well if there are a huge numbers of ties. For example, even if 97% of data were at y=0, clumped at zero, this is no issue. The model handles ceiling effects and floor effects. If y is bimodal or trimodal, no problem again. The Hmisc package has the functions lrm (discrete ordnial and can handle 200 intercepts) and orm (more for continuious data and can handle 8,000 intercepts speedily and has other link functions also) for ordinal regression. ") ,
     
         "."))
   
 })
 
  
 
  
 
```

### Listing

 

```{r listings4}


 DT::renderDataTable({

    p <-  por()$result
     
      
      p$phrase <- p$tag <- NULL
      
       #p <- as.data.frame(p)
       namez <- names(p)
      
  d1 <-  DT::datatable(p, rownames=FALSE,
                  plugins = 'natural',
                  options = list(
                    columnDefs = list(list(type = 'natural', targets = c(4,5)))
                  ))
    
  
     
  
      d1<- DT::formatRound(d1,  columns=namez ,  digits=3)
      
      d1
})

```   
 

### Probabilities

 

```{r alt4}


 DT::renderDataTable({

    
    # selection of odds ratios
    or <- por()$or
    p <- por()$P
 
    res2 = matrix(NA, nrow=length(or), ncol=length(p)  +1  )
    
    # cell probabilities 
    for (i in 1:length(or)) {
      
     res2[i,] <- as.vector(c (or[i], Hmisc::pomodm(p=p, odds.ratio=or[i])))
     
    }

 
    namez <- paste0("p", 1:length(p))
    namez <- c("Odds ratio", namez)
    res2 <- as.data.frame(res2)
    names(res2) <- namez
    
 d1 <- DT::datatable(res2, rownames=FALSE,  
                      
                  plugins = 'natural',
                  options = list(#autoWidth=TRUE,
                                 pagelength=15,
                                 lengtMenu=c(20),
                                 dom="lfrtBip",
                                 buttons=c('excel')
                     
                  ))
  
  d1<- DT::formatRound(d1, columns=namez  , digits=3)
  
  d1
  
  
})  
    

```   
 

### Cum. probabilities

 

```{r alt5}
   DT::renderDataTable({

    
    # selection of odds ratios
    or <- por()$or
    p <- por()$P
  
   res2 = matrix(NA, nrow=length(or), ncol=length(p)  +1  )
    
    # cell probabilities 
    for (i in 1:length(or)) {
      
    x <-  Hmisc::pomodm(p=p, odds.ratio=or[i])
    res2[i,] <- (c(or[i],rev(cumsum(rev(x))[1: (length(p))])))
     
    }

 
    namez <- paste0("y>=", 1:length(p))
    namez <- c("Odds ratio", namez)
    res2 <- as.data.frame(res2)
    names(res2) <- namez
    
 d2 <- DT::datatable(res2, rownames=FALSE,  
                      
                  plugins = 'natural',
                  options = list(#autoWidth=TRUE,
                                 pagelength=15,
                                 lengtMenu=c(20),
                                 dom="lfrtBip",
                                 buttons=c('excel')
                     
                  ))
  
  d2<- DT::formatRound(d2, columns=namez  , digits=3)
  
  d2
  
  
  
  
})  
     


```   
 

### Means and medians

 

```{r alt6}
   DT::renderDataTable({

    
    # selection of odds ratios
    or <- por()$or
    p <- por()$P
  
   res2 = matrix(NA, nrow=length(or), ncol=3 )
    
    # means and medians
    for (i in 1:length(or)) {
    
    res2[i,] <- (c(or[i],     Hmisc::pomodm(1:length(p), p, odds.ratio=or[i])))
     
    }

  
    namez <- c("Odds ratio", "Mean","Median")
    res2 <- as.data.frame(res2)
    names(res2) <- namez
    
 d2 <- DT::datatable(res2, rownames=FALSE,  
                      
                  plugins = 'natural',
                  options = list(#autoWidth=TRUE,
                                 pagelength=15,
                                 lengtMenu=c(20),
                                 dom="lfrtBip",
                                 buttons=c('excel')
                     
                  ))
  
  d2<- DT::formatRound(d2, columns=namez  , digits=3)
  
  d2 
  
})  
      



```   

### means and medians v odds ratio

```{r means}

# see ref 2


 k <- c(rep(0, 16), rep(1, 7), rep(2, 171), rep(3, 115), rep(4, 54))
 kp <- (c(as.vector(table(k))) / sum(table(k)))


renderPlot({
  
     
    kp <- por()$P

    kx <- 1:length(kp)
 
    ors <- seq(0.2, 5, length=200)
    
    w <- pomodm(kx, kp, odds.ratio=1)
    
    z <- data.table(or=ors)
    u <- z[, as.list(w - pomodm(kx, kp, odds.ratio=or)), by=or]  # subtract
    m <- meltData(or ~ mean + median, data=u)   # is in Hmisc
    
    ggplot(m, aes(x=or, y=value, color=variable)) + geom_line() +
      geom_vline(xintercept=1, alpha=0.3) +
      guides(color=guide_legend(title='')) +
      xlab('Odds Ratio') + ylab('Difference Between Groups')


})

  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------

``` 


Ordinal (sim)
===

Column {.sidebar}
-----------------------------------------------------------------------

**Enter cell probabilities of interest separated by a comma. There will be as many intercepts as possible levels of y  minus 1. Category probabilities must sum to 1!**

```{r po sim time}
          
          splitLayout(
          textInput("p1s",    div(h5(tags$span(style="color:blue", "hyp. proportions \U1D7B9 1...n"))),    
          value= ".222,.323,.455" ),)
           #"0.044, 0.019, 0.471, 0.317, 0.149"
          splitLayout(
          textInput("ors", div(h5(tags$span(style="color:blue", "odds ratio"))), 
          value= "1.840431"),  )
          
          splitLayout(
          textInput("alphas", div(h5(tags$span(style="color:blue", "\U1D7AA (type I error two-sided)"))), 
          value= "0.05"),  )
          
          splitLayout(
          textInput("Qs",    div(h5(tags$span(style="color:blue", "ratio for unequal randomisation"))),   
          value= "1"),)          
          
          splitLayout(
          textInput("ss",    div(h5(tags$span(style="color:blue", "simulations"))),   
          value= "500"),)                                
                             
                
          splitLayout(
          textInput("N",    div(h5(tags$span(style="color:blue", "total sample size"))),   
          value= "400"),)        
          
    
          br()
   
          
 pors <- reactive({
  
        sig.level <-   (as.numeric(unlist(strsplit(input$alphas,","))))    
        P         <-   (as.numeric(unlist(strsplit(input$p1s   ,","))))    
        Q         <-   (as.numeric(unlist(strsplit(input$Qs    ,","))))    # fraction
        or        <-   (as.numeric(unlist(strsplit(input$ors   ,","))))   
        ss        <-   (as.numeric(unlist(strsplit(input$ss    ,","))))
        N         <-   (as.numeric(unlist(strsplit(input$N     ,","))))
#------------------------------------------------------------------------------------------------------------  
          # code to accommodating varying number of betas
        
          #n= seq(2,input$x_rangepos[2], 2)          # total sample size
          
          #--------------------------------------------------------------------------
          # manual run through 
          # n=100000
          # t.cryo <- c(rep(0, 16), rep(1, 7), rep(2, 171), rep(3, 115), rep(4, 54))
          # t.octa <- c(rep(0, 32), rep(1, 11), rep(2, 162), rep(3, 106), rep(4, 69))
          # (P <- (c(as.vector(table(t.cryo))) / sum(table(t.cryo))))
          # beta_trt <- log(1.7)
          
          #--------------------------------------------------------------------------
          # input probabilities, total sample size, trt effect on log scale , and fraction for randomisation
        
          # for future eamonn, POsim is the tmpfun function below but written to accommodate
          # varying number of categories.
       
          POsim <- function(P, n, beta_trt, Q) 
            
            {
            
              #------------------------------------------
              L <- length(P)                            # how many probabilities are there?
              tmp <- runif(n)                           # use this to determine y
              m = matrix(NA, nrow=(n), ncol=L-1 )       # use to help calculate y
              
              
              # so 2 = 2/3 to 1
              # so 3 = .75 to1
              p1 <- 1/(Q+1) 
        
              p2 <- 1- p1 
                # treatment indicator
              trt <- sample(x=c(0, 1), size=n, prob=c(p2, p1) , replace=TRUE)
               
              #------------------------------------------
              # get the cum log odds p1/p2+p3+p4+p5 , p1+p2 / p3+p4+p5 ....
              lo <- c()
              for ( i in 1:L) {lo[i] = (log(  sum(P[1:i]) / (1 - sum(P[1:i]) ) ) )}
              lo <- lo*-1
              
              #-------------------------------------------
              
              for (i in 1:L-1) {  
                
                  assign(paste0("beta_level", i), lo[i])  # assign lo to beta_level objects
                
                  trt.eff <- beta_trt*trt                 # randomized trt. effect assigned
                  
                  #  work out log odds for each level + trt
                  eta   <- trt.eff + eval(parse(text = paste0("beta_level",i))) 
                    
                  probs <- exp(eta)/(1+exp(eta)) # work out probs
                  
                  assign(paste0("p", i), probs)  # assign to objects
                   
                  m[,i] <- (tmp  < eval(parse(text = paste0("p",i))))*1  # capture y
                  
              } 
           
               y <-   apply(m,1,sum) 
              
               f1 <- lrm(y~trt) 
               
               f1$stats[5]
          }
           
           # manual run through ------------------------------------------------------
           # sims =500
           # n=402
           # t.cryo <- c(rep(0, 16), rep(1, 7), rep(2, 171), rep(3, 115), rep(4, 54))
           # (P <- (c(as.vector(table(t.cryo))) / sum(table(t.cryo))))
           # 
           # out <- replicate(sims, POsim(P =P, n=N, beta_trt=log(1/1.7) ) )
           # mean( out <= 0.05 )  # PASS 
           # -------------------------------------------------------------------------
           
           # execute the function
           #--------------------------------------------------------------------------
           out <- replicate(ss, POsim(P =P, n=N, beta_trt=log(or), Q=Q ) )
           pvalue <- mean( out <= sig.level )  #  power
           #-------------------------------------------------------------------------
    
           
            n1 <- round(1/(Q+1) * N)
        
            n2 <- N- n1 

            harrell <-  Hmisc::popower(p=P, odds.ratio=or, n1=n1, n2=n2,  alpha=sig.level )[[1]]
    
           
     return(list(  
       
       pvalue = pvalue, harrell=harrell
       
      ))    
 
 })
       
           
           
           
           
       
#------------------------------------------------------------------------------------------------------------        
        
        
# standard superiority
# tmpfun <- function(n, beta_trt, beta_level4, beta_level3, beta_level2, beta_level1) {
#   
#   trt <- sample(c(0, 1), n, replace=TRUE) # trt indicator
#   
#   trt.eff <- beta_trt*trt 
#   
#   
#   eta4    <- trt.eff +beta_level4  
#   eta3    <- trt.eff +beta_level3         
#   eta2    <- trt.eff +beta_level2         
#   eta1    <- trt.eff +beta_level1     
#   
#   p1 <- exp(eta1)/(1+exp(eta1))    
#   p2 <- exp(eta2)/(1+exp(eta2))   
#   p3 <- exp(eta3)/(1+exp(eta3))   
#   p4 <- exp(eta4)/(1+exp(eta4))   
#   
#   tmp <- runif(n)
#   y <- (tmp < p1) + (tmp < p2) + (tmp < p3)  + (tmp < p4)
#   f1 <- lrm(y~trt) 
#   f1$stats[5]
# }
# 
# # set up 
# t.cryo <- c(rep(0, 16), rep(1, 7), rep(2, 171), rep(3, 115), rep(4, 54))
# t.octa <- c(rep(0, 32), rep(1, 11), rep(2, 162), rep(3, 106), rep(4, 69))
# (p <- (c(as.vector(table(t.cryo))) / sum(table(t.cryo))))
# 
# # get the cum log odds p1/p2+p3+p4+p5 , p1+p2 / p3+p4+p5 ....
# lo <- c()
# for ( i in 1:5) {lo[i] = (log(  sum(p[1:i]) / (1 - sum(p[1:i]) ) ) )}
# lo <- lo*-1
# 
# #----------------------------------------------------
# # execute1.7 , I validated these using PASS 
# out <- replicate(500, tmpfun(402,log(1.7),  lo[1], lo[2], lo[3], lo[4]))
 

```
 
 
## Column {.tabset .tabset-fade}

### Power

```{r  plot6, eval=TRUE}

#  DT::renderDataTable({
# 
#       p <-  pors()$pvalue
#       h  <- pors()$harrell
#       
#       p <-  as.data.frame(cbind(h ,p))
#       namez <- c("Hmisc::popower","Simulated power")
#       names(p) <- namez
#     
#       d1 <-  DT::datatable(p, rownames=FALSE,
#                       plugins = 'natural',
#                       )
#     
#       d1 <- DT::formatRound(d1,  columns=namez ,  digits=5)
#       
#       d1
# })

 
#-------------------------------------------------------------------------------------------------------

h5(htmlOutput("intro1")) 
br()
 

#-------------------------------------------------------------------------------------------------------

 output$intro1 <- renderText({  # create interactive text t1

 
    print(paste0(
      
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
               
               "Power for proportional odds model")   ,
      br(), 
         br(), 
          br(), 
      
      
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",  pors()$harrell,
               
               "this is power from Hmisc::popower ") ,
     
        br(), 
     
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",  pors()$pvalue,
               
               "this is power from simulation ") ,
     
      br(),  br(), 
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
               
               "Proportional odds (PO) and ordinal logisitc regression are synonyms. Frank Harrell's Hmisc::lrm function is used in this app, the parameterisation is pr[Y >= j|X]. When Y=0,1, the parameterisation is exactly that for binary logistic regression. This may be different to other PO model functions. For example, the PASS power sample software's procedure 'Tests for Two Ordered Categorical Variables' uses the opposite parameterisation, so an odds ratio of say 3/2 in this app is equivalent to and odds ratio of 2/3 with that software and vice versa. If we consider higher categories as worse outcomes, the default 1.7 odds ratio, indicates that the treatment relative to  placebo in truth is associated with a 1.70 times increased odds of having a more serious outcome. There is a proportional effect of treatment across the scale of the ordinal outcome.") ,

   br(),  br(), 
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
               
               "For the randomisation allocation, 1 is equal to 1:1 randomisation. If 0.33 is entered for unequal randomisation, 75% of patients are randomised to the treatment arm.") ,
      
   br(),  br(), 
       tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
               
               "With the PO model, every category can even have only 1 entry. The WRST test works best when there are no ties (P values are more accurate). The PO model also works well if there are a huge numbers of ties. For example, even if 97% of data were at y=0, clumped at zero, this is no issue. The model handles ceiling effects and floor effects. If y is bimodal or trimodal, no problem again. The Hmisc package has the functions lrm (discrete ordnial and can handle 200 intercepts) and orm (more for continuious data and can handle 8,000 intercepts speedily and has other link functions also) for ordinal regression. ") ,
   
   
       "."))

 })
# 
 
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------

``` 

Non PO
===

```{r, nopox}


 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# start of app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
```

Column {.sidebar}
-----------------------------------------------------------------------

**Enter cell probabilities of interest separated by a comma. Must sum to 1**

```{r nopo input}

          splitLayout(
          textInput("p1_nopo",    div(h5(tags$span(style="color:blue", "Ref proportion(s) \U1D7B9 1..n"))),    
          value= "0.66, 0.15, 0.19"),)
           
          splitLayout(
          textInput("p2_nopo", div(h5(tags$span(style="color:blue", "Trt proportion(s) \U1D7B9 1..n"))), 
          value= "0.40, 0.00, 0.60"),  )
          
          splitLayout(
          textInput("p3_nopo", div(h5(tags$span(style="color:blue", "Trt proportion(s) \U1D7B9 1..n"))), 
          value= "0.58, 0.15, 0.27,"),  )
            
          splitLayout(
          textInput("p4_nopo", div(h5(tags$span(style="color:blue", "Trt proportion(s) \U1D7B9 1..n"))), 
          value= "0.58, 0.20, 0.22"),  )
          
          splitLayout(
          textInput("alpha_nopo", div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= "0.025"),   )
          
          splitLayout(
          textInput("side_nopo", div(h5(tags$span(style="color:blue", "\U1D7AA (1 or 2 side)"))), 
          value= "1"),  )
          
          splitLayout(
          textInput("Q_nopo", 
          div(h5(tags$span(style="color:blue", "ratio for unequal randomisation \n (0.5 for equal randomisation)"))), 
          value= "0.53"),)                                
                                        
          sliderInput('x_range_nopo', 'Plot x-range', value = c(0,1500),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_range_nopo', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

          br()
          
          
#             p1_nopo = c("0.044, 0.019, 0.471, 0.317, 0.149")
# 
#   p2_nopo = c("0.02823529, 0.02588235, 0.33764706, 0.36411765, 0.24411765")
# 
#   p3_nopo  =c("0.02588235, 0.02823529, 0.33764706, 0.36411765, 0.24411765")
# 
#    p4_nopo = c("0.02823529, 0.02588235, 0.36411765,  0.33764706,0.24411765")
# 
#  alpha_nopo = "0.025, 0.05"
# 
#   side_nopo= "1"
# 
#  Q_nopo = "0.5"
# 
#          x_range_nopo  = c(0,800)
#  y_range_nopo  = c(0,1)
# 
# 
#             A <-   sig.level <-   (as.numeric(unlist(strsplit( alpha_nopo,","))))
#           Q         <-   (as.numeric(unlist(strsplit( Q_nopo,"," ))))    # fraction
#        side         <-   (as.numeric(unlist(strsplit(side_nopo,"," ))))
#           p1         <-  (  p1_nopo)
#           p2        <-   ( p2_nopo )
#           p3         <-  (  p3_nopo)
#           p4        <-   ( p4_nopo )
# 
# n= seq(2,x_range_nopo[2], 2)
#            #

   
 por_NOPO <- reactive({
  
 A <-   sig.level <-    (as.numeric(unlist(strsplit(input$alpha_nopo,","))))    
         Q         <-   (as.numeric(unlist(strsplit(input$Q_nopo,   "," ))))    # fraction
      side         <-   (as.numeric(unlist(strsplit(input$side_nopo,"," ))))
         p1         <-  (input$p1_nopo)    
         p2        <-   (input$p2_nopo)
         p3         <-  (input$p3_nopo)    
         p4        <-   (input$p4_nopo)
        
        n= seq(2,input$x_range_nopo[2], 2)
 
        #new
        d <- tidyr::expand_grid(p1 = p1, p2=p2,  p3=p3, p4=p4,alpha=A, frac =Q, n=n , side=side)
        d$n1 <- round(d$n*d$frac  )
        
        d$n2 <- d$n - d$n1 
      
        L <- reshape2::melt(d,  id.vars=c("n", "alpha", "frac","side","p1"),
           measure.vars=c("p2","p3","p4") )
         
         
         
         
 #end new
        
    #--------------------------------------------------------------------------------------------------------------------
    # return power function
    non_po_power<- function(alpha, t, p, q, N, side) {
      D <- length(p)
      Z_alpha <- qnorm(1-alpha/side)
      numerator <- 12 * t * (1 - t) * N * (sum(sapply(2:D, function(x) p[x] * sum(q[1:(x-1)]))) + 0.5 * sum(p * q) - 0.5)^2
      denominator <- (1 - sum(sapply(1:D, function(x) ((1 - t) * p[x] + t * q[x])^3)))
      Z_beta <- sqrt(numerator / denominator) - Z_alpha
      return(pnorm(Z_beta))
    }
    
    # To invoke the function, provide values for alpha, side, t, p, q, D, and N, for example:
 
#  
    L$power=NA
    
  for(i in 1: dim(L)[1]) {   
 
    p <- (as.numeric(unlist(strsplit(L$p1[i],","))))  
   
    L$power[i] <- non_po_power(alpha = L$alpha[i], side=L$side[i], t = L$frac[i], 
                               p = p,  q =(as.numeric(unlist(strsplit(L$value[i],",")))) ,  N = L$n[i])
    #--------------------------------------------------------------------------------------------------------------------
 }
 
 
# Function to round numbers in a string for dispay purposes
round_numbers_in_string <- function(num_string) {
  # Step 1: Split the string into individual numbers
  num_vector <- strsplit(num_string, ",")[[1]]
  
  # Step 2: Convert the split strings to numeric values
  num_vector <- as.numeric(trimws(num_vector))
  
  # Step 3: Round the numeric values
  rounded_vector <- round(num_vector, digits = 3)
  
  # Step 4: Combine the rounded values back into a single string
  rounded_string <- paste(rounded_vector, collapse = ", ")
  
  return(rounded_string)
}

# Apply the function to the num_string column
L$value <- sapply(L$value, round_numbers_in_string)

#--------------------------------------------------------

 ##--txt for legend
        x <- L
           
        txt <- with(x,paste0("Treatment outcome distribution\n",value,"\nalpha ",alpha, ", side ",side,", ratio=",frac,"\n"))
 
        x$phrase <- txt
      
        x$Scenario <- as.character(x$phrase)
        
        x$phrase <- NULL
        
        L <- x
    
 
    return(list(  
       
       result=L
       
      ))    
 
 })
       
 
 
 
  

```
 
 
## Column {.tabset .tabset-fade}

### Chart 3

```{r nopo, eval=TRUE}


renderPlot({
  
 p =      por_NOPO()$result
  
 p <- p[complete.cases(p), ]
 
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_range_nopo[2] <= 1000, 50,
           ifelse(input$x_range_nopo[2] > 1000 & input$x_range_nopo[2] < 3000 ,200
                       ,  500))
 
  #-----------------------------------------------------------------------
   
  p <- as.data.frame(p)
  p$ratio <- factor(p$frac)
  p$value <-  factor(p$value) #formatz2(as.numeric(p$value)) 
  p$alpha <- factor(p$alpha)
  p$side <-    factor(p$side)
  all <- ggplot(p, aes(x = n, y = power, 
                    group = interaction(ratio, value, alpha, side),
                      
                   colour = Scenario
                  
                  )) +  
  geom_line() +
 
  scale_y_continuous(breaks = 
                       seq(input$y_range_nopo[1],     input$y_range_nopo[2], by = 0.1),
                limits = c(input$y_range_nopo[1],     input$y_range_nopo[2])) +
    
  scale_x_continuous(breaks =
                       seq(input$x_range_nopo[1],  input$x_range_nopo[2], skips), 
                limits = c(input$x_range_nopo[1],  input$x_range_nopo[2])) +
    
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +


  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Total Sample Size', color = "Scenario", linetype="Ratio" )+
 
  labs(caption = paste("- Alpha the type I assertion probability. \n- The allocation ratio affects the second group. \n- Can use to power non-inferiority design, recall alpha 0.025 one sided is the same as 0.05 two sided. \n- Uses Zhao et al. equation 12 and reproduces selected examples from paper (see references)." )) +

  ggtitle(paste0(" Power (or total sample size) for non proportional odds (superiority and non-inferiority) ") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
#-----------------------------------------------------------
#ggplotly(all)
 })
 
  
  

 
```

### Listing

 

```{r listings9}


 DT::renderDataTable({

    p <-   por_NOPO()$result
      
    p$p1 <- p$p2 <- NULL
    
       namez <- names(p)
      
  d1 <-  DT::datatable(p, rownames=FALSE,
                  plugins = 'natural',
                  options = list(
                    columnDefs = list(list(type = 'natural', targets = c(4,5)))
                  ))
    
  
     
  
      d1<- DT::formatRound(d1,  columns=namez ,  digits=3)
      
      d1
})

  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  
``` 

Survival
====


Column {.sidebar}
-----------------------------------------------------------------------

**Enter parameters of interest separated by a comma**

```{r surv1_surv2}

  
    
  
          splitLayout(
          textInput("hrs_surv2",    
          div(h5(tags$span(style="color:blue", "hazard ratio"))),    
          value= "2,1.5"),)

          splitLayout(
          textInput("alphas_surv2", 
          div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= "0.05"), )
           
          splitLayout(
          textInput("sidess_surv2",    
          div(h5(tags$span(style="color:blue", "one or two sided"))),    
          value= "2"),)
                                         
          splitLayout(
          textInput("ros_surv2",    
          div(h5(tags$span(style="color:blue", "ratio for unequal randomisation"))),   
          value= "1"),)                                
                                        
          sliderInput('x_ranges_surv2', 'Plot x-range', value = c(0,400),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_ranges_surv2', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

   
          br()
          
          
                 
 surv99 <- reactive({
 
#     #----------------------------------------------------------------------------------------------
 
    hr      <- (as.numeric(unlist(strsplit(input$hrs_surv2,","   ))))
    alpha   <- (as.numeric(unlist(strsplit(input$alphas_surv2,","))))
    side    <- (as.numeric(unlist(strsplit(input$sidess_surv2,","))))
    ro      <- (as.numeric(unlist(strsplit(input$ros_surv2,","   ))))

      
 
    
    
      n= seq(2,input$x_ranges_surv2[2], 2)
     # 
     # n=seq(2, 100,2)
     # alpha=0.05
     # hr=.5
     # side=2
     # ro=1
     #  
         d <- tidyr::expand_grid(hr=hr,   alpha=alpha, ratio =ro, n=n , sided=side)
         
         
         d$hr2 <- ifelse(d$hr>1, 1/d$hr, d$hr)
         
         d$n1  <- round(d$n*d$ratio)
         d$n2  <- d$n - d$n1 
         
         d$power  <- NA
    
#----------------------------------------------     gsDesign::nEvents
eamonn <- function (hr = 0.6, alpha = 0.025, beta = 0.1, ratio = 1, sided = 1, 
    hr0 = 1, n = 0, tbl = FALSE) 
{
    #if (sided != 1 && sided != 2) 
     #   stop("sided must be 1 or 2")
    c <- sqrt(ratio)/(1 + ratio)
    delta <- -c * (log(hr) - log(hr0))
    if (n[1] == 0) {
        n <- (stats::qnorm(1 - alpha/sided) + stats::qnorm(1 - 
            beta))^2/delta^2
        # if (tbl) {
        #     n <- data.frame(cbind(hr = hr, n = ceiling(n), alpha = alpha, 
        #         sided = sided, beta = beta, Power = 1 - beta, 
        #         delta = delta, ratio = ratio, hr0 = hr0, se = 1/c/sqrt(ceiling(n))))
        # }
        # return(n)
    }
    else {
        pwr <- stats::pnorm(-(stats::qnorm(1 - alpha/sided) - 
            sqrt(n) * delta))
        if (tbl) {
            pwr <- data.frame(cbind(hr = hr, n = n, alpha = alpha, 
                sided = sided, beta = 1 - pwr, Power = pwr, delta = delta, 
                ratio = ratio, hr0 = hr0, se = sqrt(1/n)/c))
        }
        return(pwr)
    }
}
#-----------------------------------------------------------------------------
        d$power  <-   eamonn(
                                   hr = d$hr2,
                                   alpha = d$alpha,
                                   ratio = d$ratio,
                                   sided = d$sided,
                                   n = d$n)
      

       d$hr2 <- NULL
       #-------------------------------------------------------
       # code to help with legend
 
      
      x<-d
      x$phrase <- with(x, paste("hr =",x$hr,", \U1D7AA=",x$alpha, ", ratio=",x$ratio, ", sided=",x$sided))
     
      return(list(res=x
      
     ))    

})
      
      
  
 
 
```
$\alpha$ type I assertion error
 
<!-- ### Chart 1 -->

 
## Column {.tabset .tabset-fade}

### Chart 4

```{r surv99, eval=TRUE}


renderPlot({
  
 p =      surv99()$res
 
 
 p <- p[complete.cases(p), ]
  
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_ranges_surv2[2] <= 1000, 50,
           ifelse(input$x_ranges_surv2[2] > 1000 & input$x_ranges_surv2[2] < 3000 ,200,  500))

 
  #-----------------------------------------------------------------------
 
  all <- ggplot(p, aes(x = n, y = power, 
                
                 group = interaction(hr, alpha, ratio, sided),
              
                    colour = phrase)) + # # had hr here initally mis match with legend
  geom_line() +
 
 
  scale_y_continuous(breaks = seq(input$y_ranges_surv2[1], input$y_ranges_surv2[2], by = 0.1),
                       limits = c(input$y_ranges_surv2[1], input$y_ranges_surv2[2])) +
     
  scale_x_continuous(breaks = seq(input$x_ranges_surv2[1], input$x_ranges_surv2[2], skips), 
                     limits =   c(input$x_ranges_surv2[1], input$x_ranges_surv2[2])) +
     
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +


  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Total number of events', color = "Scenario", linetype="Ratio" )+
 
  labs(caption = paste("- Alpha the type I assertion probability.  Note, total number of patients requires information on accrual duration and maximum follow up times. If ratio <1 n1 is the smaller group. \n- Uses method of Schoenfeld two-sided test for the ratio of two hazards. Assuming exponential hazards.\n- Schoenfeld DA. Sample-size formula for the proportional-hazards regression model. Biometrics 1983;39:499-503.\n" )) +

  ggtitle(paste0(" Power (or number of events) for hazard ratio assuming exponential hazards") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
#-----------------------------------------------------------
#ggplotly(all)
 })
 
```

### Listing

```
      
 

``` 


Binary
===

 

Column {.sidebar}
-----------------------------------------------------------------------

**Enter parameters of interest separated by a comma**

```{r newbin input}


 
          splitLayout(
          textInput("p1_newbin",    div(h5(tags$span(style="color:blue", "hypothesised proportion(s) \U1D7B9 1"))),    
          value= "0.2,0.25 "),)
           
          splitLayout(
          textInput("p2_newbin",    div(h5(tags$span(style="color:blue", "hypothesised proportion(s) \U1D7B9 2"))),    
          value= "0.1,0.15 "),)
          
          splitLayout(
          textInput("alpha_newbin", div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= "0.05, 0.025"), 
                                       )
          splitLayout(
          textInput("ro_newbin",    div(h5(tags$span(style="color:blue", "ratio for unequal randomisation"))),   
          value= ".5"),)                                
                                        
          sliderInput('x_range_newbin', 'Plot x-range', value = c(0,800),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_range_newbin', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1, step=.05,ticks=F)

   
          br() 
          
          
          
         newbin<- reactive({
  
         p1         <-   (as.numeric(unlist(strsplit(input$p1_newbin,","))))    
         p2         <-   (as.numeric(unlist(strsplit(input$p2_newbin,"," ))))    # fraction
         sig.level  <-   (as.numeric(unlist(strsplit(input$alpha_newbin,"," ))))
         frac       <-   (as.numeric(unlist(strsplit(input$ro_newbin,"," )))) 
        
         n= seq(2,input$x_range_newbin[2], 2)
      
         d <- tidyr::expand_grid(p1 = p1, p2=p2, alpha=sig.level, frac =frac, n=n )
         
         d$n1 <- round(d$n*d$frac  )
         d$n2     <- d$n - d$n1 
         
         d$power  <- NA
         d$power  <- bpower(n1 = d$n1, n2 =d$n2, p1 = d$p1, p2 =  d$p2, alpha = d$alpha)  
          
          
       #-------------------------------------------------------
       # code to help with legend
 
      
      x<-d
      x$phrase <- with(x, paste("\U1D7B9 1=",x$p1,", \U1D7B9 2=",x$p2,"\n\U1D7AA=",x$alpha, ", ratio=",x$frac))
     
      return(list(res=x
      
     ))    

})
      
 
```

$\alpha$ type I assertion error 

## Column {.tabset .tabset-fade}

### Chart 5

```{r newbin plot1}

renderPlot({
  
  p =      newbin()$res
  
  p <- p[complete.cases(p), ]
  
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_range_newbin[2] <= 1000, 50,
           ifelse(input$x_range_newbin[2] >  1000 & input$x_range_newbin[2] < 3000 ,200, 500))
   
  # -------------------------
  
  all <-ggplot(p, aes(x = n, y = power,  
                    group=interaction(p1,p2,alpha, frac),
                    colour = phrase)) +
  geom_line() +
    
 
  scale_y_continuous(breaks = seq(input$y_range_newbin[1], input$y_range_newbin[2], by = 0.1),
                     limits =   c(input$y_range_newbin[1], input$y_range_newbin[2])) +
  scale_x_continuous(breaks = seq(input$x_range_newbin[1], input$x_range_newbin[2], skips),
                     limits =   c(input$x_range_newbin[1], input$x_range_newbin[2])) +
    
  
    
  theme_bw() +
  theme( 
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),
     
    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),
    
    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),
   
    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),
    
    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +
  
  
  labs(y="Power", x = 'Total Sample Size', color = "Scenarios", linetype="Ratio" )+
  labs(caption = paste("- Ratio, see legend,less than 1, n2 is the smaller group.\n- Where the ratio of sample sizes n1/n2=x in one case and n2/n1=x in another (where x is a constant) the power of the test differs between these scenarios.\n- Uses method of Fleiss, Tytun, and Ury (but without the continuity correction) to estimate the power (or the sample size to achieve a given power) of a two-sided test for the difference in two proportions. \n- Fleiss JL, Tytun A, Ury HK (1980): A simple approximation for calculating sample sizes for comparing independent proportions. Biometrics 36:343–6.\n" )) +
  ggtitle(paste0("Power (or sample size) for difference in two proportions") ) 

#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
  #-----------------------------------------------------------------------
#ggplotly(all)
 })
    
      
 
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------



``` 

Bernoulli
===


Column {.sidebar}
-----------------------------------------------------------------------

**Enter hypothesised pop. proportion(s) and those postulated separated by commas**

```{r bern}
          
    

          splitLayout(
          textInput("p1_h0",    
          div(h5(tags$span(style="color:blue", "Hypothesised"))),    
          value= "0.37, 0.3,.50, 0.55"),)

          splitLayout(
          textInput("p1_h1",    
          div(h5(tags$span(style="color:blue", "Postulated hypothesis"))),    
          value= ".68, .5"),)
           
          splitLayout(
          textInput("alpha_bern", 
          div(h5(tags$span(style="color:blue", "\U1D7AA (type I error) 1 sided"))), 
          value= "0.025"),  )
          
          splitLayout(
          textInput("target", 
          div(h5(tags$span(style="color:blue", "target power"))), 
          value= "0.8, 0.9"),  )
           
          sliderInput('x_ranges_bern', 'Plot x-range', value = c(0,120),
                  min = 0, max = 1000,step=20,ticks=F)
          
          sliderInput('y_ranges_bern', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

          br()
      

 berni <- reactive({
  
        sig.level  <-   (as.numeric(unlist(strsplit(input$alpha_bern,","))))    
        h0         <-   (as.numeric(unlist(strsplit(input$p1_h0,     ","))))
        h1         <-   (as.numeric(unlist(strsplit(input$p1_h1,     ","))))
        target     <-   (as.numeric(unlist(strsplit(input$target,    ","))))
 #------------------------------------------------------------------------------------------------------------  
        
    
       n= seq(2,input$x_ranges_bern[2], 1)
       # h0=.5
       # h1=c(.68)
       # sig.level=.025
       # n= seq(2,400, 1)
       #  target=c(.8,.9)

        

        
        d <- tidyr::expand_grid(h0=h0,  h1=h1, alpha= sig.level, beta=NULL,  n=n )
        
        d <-  gsDesign::nBinomial1Sample(p0 = d$h0, p1=d$h1,alpha = d$alpha, beta=NULL, n = d$n)
        
        d <- tidyr::expand_grid(d, target=target)
        
        # work on finding the numerators, and point where power is always above target, 
        # recall saw tooth relationship

        d$group <- paste0("H0=",d$p0,", H1=",d$p1," \U1D7AA=",d$alpha, "target=",d$target )
        
        d <- plyr::arrange(d, group)
        
           # flag where power is reached 
           library(dplyr)
           # d1 <-  d %>%
           #   group_by(group) %>% 
           #    mutate(Attain = Power > target)  
           
           # filter where power is reached
           PP <-   d %>% 
              group_by(group) %>% 
              filter(Power > target) 
         
           # now we want to id where power does not drop below target
           # flag if there is a gap in n
           PP <- PP %>%
             group_by(group) %>% 
              mutate(conservative =  c(0, (diff(n)) >= 2))  
          
           # select the minimum , this is the point where power is reached initially
           PP1 <-  PP %>%
             group_by(group) %>% 
               slice_min(b, n = 1)
                    
          # now focus on where power is consistetly reached with increasing n
          # that is never dips below target power
          PP2 <- PP%>%
           group_by(group) %>% 
            filter(conservative==1) 
        
          # second slice as there may be multiple non consecutive gaps 
           PP2 <- PP2%>%
           group_by(group) %>% 
             slice_max(b, n = 1)  # max rather than min (to ensure we don't pick another incidence after which power drops below our target)
        
          # stick together
          coord <- rbind(PP1, PP2)
      
          # overwrite without target info
          d$group <- paste0("H0=",d$p0,", H1=",d$p1,", \U1D7AA=",d$alpha )
        
  
 
  return(list(

       d=d, coord=coord

      ))

 })
         
 
 
 # checks
 # n<-23 #samplesize
 # #n <-24
 # pval<-replicate(5000,{ #replicationsofexperiment
 # x<-rbinom(1,size=n, #data-generatingmodelwith
 # prob=0.37+0.31) # minimumrelevanteffect
 # binom.test(x,n=n,p=0.37)$p.value #p-valueoftestagainstH0
 # })
 # mean(pval<0.05)
 #         
 # n <-81
 # pval<-replicate(5000,{ #replicationsofexperiment
 # x<-rbinom(1,size=n, #data-generatingmodelwith
 # prob=0.5+0.18) # minimumrelevanteffect
 # binom.test(x,n=n,p=0.5)$p.value #p-valueoftestagainstH0
 # })
 # mean(pval<0.05)
 #         
 #         
         
 
# require(gsDesign)
# nBinomial1Sample(
#   p0 = 0.37,
#   p1 = 0.68,
#   alpha = 0.025,
#   beta = NULL,
#   n = 2:30,
#   outtype = 2,
#   conservative = FALSE
# )
# conservative	
# operative when outtype=1 or 2 and beta != NULL. Default FALSE selects minimum sample 
# size for which power is at least 1-beta. When conservative=TRUE, the minimum sample 
# sample size for which power is at least 
#1-beta and there is no larger sample size in the input n where power is less than 1-beta.
            
 # exact
   
 # with(list(mu = 0.3, mu.alt = 0.5, alpha = 0.025, n = 54), (mean(sapply(rbinom(1e4, n, mu.alt), function(x) prop.test(x, n, mu, alternative = "greater")$p.value <= alpha))))        
 # 
 # nBinomial1Sample(
 #     p0 = 0.3,
 #       p1 = 0.5,
 #       alpha = 0.025,
 #       beta = NULL,
 #       n = 50:55,
 #       outtype = 2,
 #       conservative = FALSE
 #     )
 
 
 ## approx
 
#  The last approaches matches Stata (normal approx I believe), both give 44
# 
# sampsi .3 .5, alpha(0.025) power(.80) onesample oneside
# 
# p=0.5 ; p0=0.3 ; alpha=0.025 ; beta=0.20
# 
# (n=p0*(1-p0)*((qnorm(1-alpha)+qnorm(1-beta)*sqrt(p*(1-p)/p0/(1-p0)))/(p-p0))^2)
# 
# ceiling(n)
# 
# z=(p-p0)/sqrt(p0*(1-p0)/n)
# 
# (Power=pnorm(sqrt(p0*(1-p0)/p/(1-p))*(abs(z)-qnorm(1-alpha))))
# 
# 
# There are no choices lying between n and its neighbors n-1 and n+1 Thus, it's unrealistic (and unproductive) to expect to find a sample size that achieves exactly say 80% power. 



 
 
 
 
```
$\alpha$ type I assertion error
 
<!-- ### Chart 1 -->

 
## Column {.tabset .tabset-fade}

### Chart 99

```{r berni99, eval=TRUE}


renderPlot({
  
  p =  berni()$d
  
  coord =  berni()$coord
 
 
  p <- p[complete.cases(p), ]
  
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_ranges_bern[2] <= 500, 10,
           ifelse(input$x_ranges_bern[2] > 500 & input$x_ranges_bern[2] < 1000 ,200,  500))

 
  #-----------------------------------------------------------------------
 
 all <-ggplot(p, aes(x = n, y = Power, 
                     
                    group = interaction(p0, p1, alpha),
               
                     colour = group)) +
   geom_line() +
 
   geom_point(data=coord, inherit.aes = FALSE,
              aes(x=n,y=Power), 
              color=ifelse(coord$conservative %in% 1 ,"red","black"),
              size=3) +
 
 
  scale_y_continuous(breaks = seq(input$y_ranges_bern[1], input$y_ranges_bern[2], by = 0.1),
                       limits = c(input$y_ranges_bern[1], input$y_ranges_bern[2])) +
     
  scale_x_continuous(breaks = seq(input$x_ranges_bern[1], input$x_ranges_bern[2], skips), 
                     limits =   c(input$x_ranges_bern[1], input$x_ranges_bern[2])) +
     
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +


  #-----------------------------------------------------------------------
 
 
  labs(y="Power", x = 'Total Sample Size', color = "Scenarios", linetype="Ratio p1:p2" )+
  labs(caption = paste("- Alpha the type I assertion probability. Binomial exact power (or the sample size to achieve a given power) of one binomial to a hypothesised population value.\n- As the sample size increases, the power of the test generally increases, but it does so in a stepwise manner due to the discrete nature of the binomial distribution, hence power fluctuates as the sample size\n changes, resulting in a sawtooth pattern. For each target, black dots denote when a target power is reached.  As mentioned power can actually decrease as the sample size is increased. Thus, the relationship between power and sample size is not monotonic. \nIf necessary, a red dot denotes the n after which power never dips below the target.\n" )) +
  ggtitle(paste0("Power (or sample size) for exact test of a simple null hypothesis in a Bernoulli experiment") ) 


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
#-----------------------------------------------------------
#ggplotly(all)
 })
 
 
 


 
```

### Critical values

 

```{r listings bern}


 DT::renderDataTable({

    p <-  berni()$coord
    
    p$group <- p$conservative <- NULL
    
    p <- plyr::arrange(p, p0,p1, target, b)
      
    namez <- names(p)
      
    d1 <-  DT::datatable(p, rownames=FALSE,
                    plugins = 'natural',
                    options = list(
                      columnDefs = list(list(type = 'natural', targets = c(4,5)))
                    ))
      
    d1 <- DT::formatRound(d1,  columns=namez ,  digits=3)
      
    d1
})

 
```

### Listing

 

```{r listings bern2}


 DT::renderDataTable({

    p <-  berni()$d
    
    p$optimal <- p$phrase <- NULL
      
    namez <- names(p)
      
    d1 <-  DT::datatable(p, rownames=FALSE,
                    plugins = 'natural',
                    options = list(
                      columnDefs = list(list(type = 'natural', targets = c(4,5)))
                    ))
      
    d1<- DT::formatRound(d1,  columns=namez ,  digits=3)
      
    d1
})
 
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
        
        
        
        
        
        
        





``` 

3 arm trial (cont. & binary sim. with fig.)
===


Column {.sidebar}
-----------------------------------------------------------------------

**Enter 3 means or proportions and select 1 or 2 for binary or continuous, Bonferroni adjusted**

```{r threearm12, eval=TRUE}
          
          splitLayout(
          textInput("link2",    div(h5(tags$span(style="color:blue", "1 for binary 2 for countinuous"))),
          value= "1"),)

          splitLayout(
          textInput("mus2",    div(h5(tags$span(style="color:blue", "3 means or 3 proportions "))),    
          value= ".9,.8,.7"),)
           
          splitLayout(
          textInput("sds2", div(h5(tags$span(style="color:blue", "3 SDs (ignored for binary data"))), 
          value= "5.22,5.22,5.22"),  )
          
          splitLayout(
          textInput("alphas2", div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= "0.05"),  )
     
          splitLayout(
          textInput("ss12",    div(h5(tags$span(style="color:blue", "no. of simulations"))),   
          value= "50000"),)                                
          
          sliderInput('x_rangepo2', 'Plot x-range', value = c(0,100),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_rangepo2', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

          br()
          
          
          
          #----------------function
        # from multiarm power simulations4.R
        
    three.arm.v2 <- function(u0, u1, u2, n,  sigma0, sigma1, sigma2, alpha1=0.05 ,  nSims=sims , out.var )
{
  
  P1 <- P2 <- P3 <- P4 <- P5 <- P6 <- 0 # counter        
          
  if (out.var %in% 1)    {    
          
  sigma0=sqrt(u0*(1-u0)) #placebo se
  sigma1=sqrt(u1*(1-u1)) #arm1 se
  sigma2=sqrt(u2*(1-u2)) #arm2 se
    
  } 
  
  for (i in 1:nSims) {
    
    y0=rnorm(1, u0, sigma0/sqrt(n)) # responses
    y1=rnorm(1, u1, sigma1/sqrt(n))
    y2=rnorm(1, u2, sigma2/sqrt(n))
    
    z1=(y0-y1)/sqrt(sigma1^2/n+sigma0^2/n) # arm1 v placebo z value
    z2=(y0-y2)/sqrt(sigma2^2/n+sigma0^2/n) # arm2 v placebo z value
    z3=(y2-y1)/sqrt(sigma2^2/n+sigma1^2/n) # arm2 v arm1 z value
    
    t1=2*(1-pnorm(z1))  # 2 sided p-value
    t2=2*(1-pnorm(z2))
    t3=2*(1-pnorm(z3))
    
    #power
    if(t1<=alpha1/2){P1=P1+1/nSims} # bonferroni
    if(t2<=alpha1/2){P2=P2+1/nSims} # bonferroni
    if(t2<=alpha1/2 & t1<=alpha1/2){P3=P3+1/nSims}  # bonferroni
    if(t2<=alpha1/3 & t1<=alpha1/3 & t3<=alpha1/3){P4=P4+1/nSims}  # bonferroni 3
    if(t2<=alpha1/3 | t1<=alpha1/3 | t3<=alpha1/3){P5=P5+1/nSims}  # bonferroni 3
    if(t2<=alpha1/2 | t1<=alpha1/2){P6=P6+1/nSims}  # bonferroni
  }
  
  # return (c( 
  #   "power arm1 v placebo being signif. ",   formatz4(P1),
  #   "power arm2 v placebo being signif. ",formatz4(P2),
  #   "power for both arms v placebo being signif.", formatz4(P3) ,
  #   "conjunctive (power to reject all null hypoth)", formatz4(P4) ,
  #   "disjunctive (power to reject at least one null hypothesis) ", formatz4(P5) ,
  #   "power for at least one arm signif. v placebo ", formatz4(P6) 
  # ))
  
  
  structure (list( 
       P1=P1,
       P2=P2,
       P3=P3,
       P4=P4,
       P5=P5,
       P6=P6 
  ))  
  
}

          
          #----------------end function
 
          
 threearmx <- reactive({
  
        sig.level <-   (as.numeric(unlist(strsplit(input$alphas2 ,","))))    
        mus       <-   (as.numeric(unlist(strsplit(input$mus2    ,","))))    
        link      <-   (as.numeric(unlist(strsplit(input$link2   ,","))))     
        sds       <-   (as.numeric(unlist(strsplit(input$sds2    ,","))))   
        ss        <-   (as.numeric(unlist(strsplit(input$ss12    ,","))))
#---------------------------------------------------------------------------------------------------
          n= seq(2,input$x_rangepo2[2], 2)
        
        # create a dataset , this will be input to function
        
        d <- tidyr::expand_grid(mu1=mus[1], mu2=mus[2], mu3=mus[3],
              sigma0=sds[1], sigma1=sds[2], sigma2=sds[3],
              alpha=sig.level, out.var=link,  n=n)
  
              bvout <- matrix(NA, ncol=6, nrow=length(n))
              bvout <- as.data.frame(bvout)
   
    #apply function to each row    
        
   for( i in 1: length(n)) {
     
         bvout[i,] <- three.arm.v2(u0=d$mu1[i], u1=d$mu2[i], u2=d$mu3[i], 
                        sigma0=d$sigma0 [i], sigma1=d$sigma1[i], sigma2=d$sigma2[i], 
                        n=d$n[i], alpha=d$alpha[i], out.var=d$out.var[i], nSims=ss) 
  
            }
       
        result <- cbind(bvout, d)
      
        names(result)  <-c("trt1 v Ctrl", "trt2 v Ctrl", "both v Ctrl", "conjunctive", "disjunctive", 
                           "at least 1", "mu1", "mu2", "mu3", "sigma0", "sigma1", "sigma2", "alpha", "out.var", "n")
 
     x <- result

    return(list(

       result=result

      ))

 })
       
 
```
 
 
## Column {.tabset .tabset-fade}

### Chart 6

```{r surv plot8, eval=TRUE}

library("reshape2")
renderPlot({
  
 p =      threearmx()$result
  
 p <- p[complete.cases(p), ]
 
 L <- melt(p, id="n", 
           measure.vars=c("trt1 v Ctrl", "trt2 v Ctrl", "both v Ctrl", "conjunctive", "disjunctive", 
"at least 1") )
 
 
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_rangepo2[2] <= 1000, 50,
           ifelse(input$x_rangepo2[2] > 1000 & input$x_rangepo2[2] < 3000 ,200
                       ,  500))

 
  all <- ggplot(data=L,
       aes(x=n, y=value, 
           colour=variable)) +
  geom_line()  +
 
  scale_y_continuous(breaks = 
                       seq(input$y_rangepo2[1], input$y_rangepo2[2], by = 0.1),
                       limits = c(input$y_rangepo2[1], input$y_rangepo2[2])) +
    
  scale_x_continuous(breaks =
                       seq(input$x_rangepo2[1], input$x_rangepo2[2], skips), 
                       limits = c(input$x_rangepo2[1],  input$x_rangepo2[2])) +
    
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +

  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Total Sample Size', color = "Scenario")+
 
  labs(caption = paste("- Alpha the type I assertion probability." )) +

  ggtitle(paste0(" Power (or total sample size) for three arms ") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
 
 })
 
  
  
 

 
```

### Listing

 

```{r listings8}


 DT::renderDataTable({

    p <-  threearmx()$result
      
       namez <- names(p)
      
  d1 <-  DT::datatable(p, rownames=FALSE,
                  plugins = 'natural',
                  options = list(
                    columnDefs = list(list(type = 'natural', targets = c(4,5)))
                  ))
    
  
     
  
      d1<- DT::formatRound(d1,  columns=namez ,  digits=3)
      
      d1
})

 
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------


``` 

3 arm trial (cont. & binary sim.)
===


Column {.sidebar}
-----------------------------------------------------------------------

**Enter 3 means or proportions and select 1 or 2 for binary or continuous, Bonferroni adjusted**

```{r threearm1}
          
          splitLayout(
          textInput("link",    div(h5(tags$span(style="color:blue", "1 for binary 2 for countinuous"))),
          value= "1"),)

          splitLayout(
          textInput("mus",    div(h5(tags$span(style="color:blue", "3 means or 3 proportions "))),    
          value= ".9,.8,.7"),)
           
          splitLayout(
          textInput("sds", div(h5(tags$span(style="color:blue", "3 SDs (ignored for binary data"))), 
          value= "5.22,5.22,5.22"),  )
          
          splitLayout(
          textInput("alphas", div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= "0.05"),  )
     
          splitLayout(
          textInput("ss1",    div(h5(tags$span(style="color:blue", "no. of simulations"))),   
          value= "500"),)                                
                             
                
          splitLayout(
          textInput("N1",    div(h5(tags$span(style="color:blue", "sample size per arm"))),   
          value= "40"),)        
          
    
          br()
   
          
 threearm <- reactive({
  
        sig.level <-   (as.numeric(unlist(strsplit(input$alphas,","))))    
        mus       <-   (as.numeric(unlist(strsplit(input$mus   ,","))))    
        link      <-   (as.numeric(unlist(strsplit(input$link  ,","))))    # fraction
        sds       <-   (as.numeric(unlist(strsplit(input$sds   ,","))))   
        ss        <-   (as.numeric(unlist(strsplit(input$ss1   ,","))))
        N         <-   (as.numeric(unlist(strsplit(input$N1    ,","))))
#------------------------------------------------------------------------------------------------------------  
      
      
        # from multiarm power simulations4.R
        
    three.arm <- function(u0, u1, u2, n,  sigma0, sigma1, sigma2, alpha1=0.05 ,  
                          nSims=sims , out.var=1 )
{
  
  P1 <- P2 <- P3 <- P4 <- P5 <- P6 <- 0 # counter        
          
  if (out.var %in% 1)    {    
          
  sigma0=sqrt(u0*(1-u0)) #placebo se
  sigma1=sqrt(u1*(1-u1)) #arm1 se
  sigma2=sqrt(u2*(1-u2)) #arm2 se
    
  } 
  
  for (i in 1:nSims) {
    
    y0=rnorm(1, u0, sigma0/sqrt(n)) # responses
    y1=rnorm(1, u1, sigma1/sqrt(n))
    y2=rnorm(1, u2, sigma2/sqrt(n))
    
    z1=(y0-y1)/sqrt(sigma1^2/n+sigma0^2/n) # arm1 v placebo z value
    z2=(y0-y2)/sqrt(sigma2^2/n+sigma0^2/n) # arm2 v placebo z value
    z3=(y2-y1)/sqrt(sigma2^2/n+sigma1^2/n) # arm2 v arm1 z value
    
    t1=2*(1-pnorm(z1))  # 2 sided p-value
    t2=2*(1-pnorm(z2))
    t3=2*(1-pnorm(z3))
    
    #power
    if(t1<=alpha1/2){P1=P1+1/nSims} # bonferroni
    if(t2<=alpha1/2){P2=P2+1/nSims} # bonferroni
    if(t2<=alpha1/2 & t1<=alpha1/2){P3=P3+1/nSims}  # bonferroni
    if(t2<=alpha1/3 & t1<=alpha1/3 & t3<=alpha1/3){P4=P4+1/nSims}  # bonferroni 3
    if(t2<=alpha1/3 | t1<=alpha1/3 | t3<=alpha1/3){P5=P5+1/nSims}  # bonferroni 3
    if(t2<=alpha1/2 | t1<=alpha1/2){P6=P6+1/nSims}  # bonferroni
  }
  
  return (c( 
    "power arm1 v placebo being signif. ",   formatz4(P1),
    "power arm2 v placebo being signif. ",formatz4(P2),
    "power for both arms v placebo being signif.", formatz4(P3) ,
    "conjunctive (power to reject all null hypoth)", formatz4(P4) ,
    "disjunctive (power to reject at least one null hypothesis) ", formatz4(P5) ,
    "power for at least one arm signif. v placebo ", formatz4(P6) 
  ))
}

##  
        
 x<-  three.arm(u0=mus[1], u1=mus[2], u2=mus[3], sigma0=sds[1], sigma1=sds[2], sigma2=sds[3], 
             n=N, alpha=sig.level, out.var=link, nSims=ss)     
        
        
     return(list(  
       
       AA =  paste(x[1],x[2]),
       BB =  paste(x[3],x[4]),
       
       CC =  paste(x[5],x[6]),
       DD =  paste(x[7],x[8]),
       
       EE =  paste(x[9],x[10]),
       FF =  paste(x[11],x[12])
       
      ))    
 
 })
       
 
 
```
 
 
## Column {.tabset .tabset-fade}

### Simulation

```{r threearmo, eval=TRUE}
 
 
h5(htmlOutput("intro2")) 
br()
 

#-------------------------------------------------------------------------------------------------------

 output$intro2 <- renderText({  # create interactive text t1

 
    print(paste0(
      
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$AA,
               
               "Power")   ,
      
         br(), 
          br(), 
      
           tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$BB,
               
              "Power")   ,
     
        br(),  br(),
  
     tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$CC,
               
              "Power")   ,
     
        br(),  br(),
   
     
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$DD,
               
              "Power")   ,
     
        br(),  br(),
     
          
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$EE,
               
              "Power")   ,
     
        br(),  br(),
     
     
          
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$FF,
               
              "Power")   ,
     
        br(),  br(),
     

       "."))

 })
 




 
```
 
 
## Column {.tabset .tabset-fade}

### Chart 6

```{r three arm plot, eval=TRUE}

library("reshape2")
renderPlot({
  
 p =      threearmx()$result
  
 p <- p[complete.cases(p), ]
 
 L <- melt(p, id="n", 
           measure.vars=c("trt1 v Ctrl", "trt2 v Ctrl", "both v Ctrl", "conjunctive", "disjunctive", 
"at least 1") )
 
 
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_rangepo2[2] <= 1000, 50,
           ifelse(input$x_rangepo2[2] > 1000 & input$x_rangepo2[2] < 3000 ,200
                       ,  500))

 
  all <- ggplot(data=L,
       aes(x=n, y=value, 
           colour=variable)) +
  geom_line()  +
 
  scale_y_continuous(breaks = 
                       seq(input$y_rangepo2[1], input$y_rangepo2[2], by = 0.1),
                       limits = c(input$y_rangepo2[1], input$y_rangepo2[2])) +
    
  scale_x_continuous(breaks =
                       seq(input$x_rangepo2[1], input$x_rangepo2[2], skips), 
                       limits = c(input$x_rangepo2[1],  input$x_rangepo2[2])) +
    
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +

  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Total Sample Size', color = "Scenario")+
 
  labs(caption = paste("- Alpha the type I assertion probability." )) +

  ggtitle(paste0(" Power (or total sample size) for three arms ") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
 
 })
 
  
        
        
        
        
        
        
        
        
        
        
        
 

``` 

Play the winner
===


Column {.sidebar}
-----------------------------------------------------------------------

**Enter 2 equal worst response rates separated by commas and best response rate**

```{r ptw inputs}
          
    #pick.winnner(nSims=1e7,  mu=c(0.2, 0.3, 0.35), nStg1=279)


          splitLayout(
          textInput("ptw_h0",    
          div(h5(tags$span(style="color:blue", "Hyp. response rates: A, B, C"))),    
          value= "0.20, 0.20, 0.30"),)

          splitLayout(
          textInput("ptw_sims",    
          div(h5(tags$span(style="color:blue", "No of Simulations"))),    
          value= "1e5"),)

          sliderInput('x_ranges_ptw', 'Plot x-range', value = c(0,100),
                  min = 0, max = 1000,step=20,ticks=F)
          
          sliderInput('y_ranges_ptw', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

          br()
      
    
```
-----------------------------------------------------------------------
**Default inputs : A one-way (3-group) randomized phase II selection design with binary outcomes will be used to determine the best group (or one of the best groups) for further study. The response rate of the worst group is assumed to be 0.2. To detect a best group response rate of 0.3 (or a maximum response rate difference of 0.1), with probability 0.9 of selecting the best group, the number of subjects needed will be 93 per group, for a total of 279 subjects across the 3 groups.**

```{r note}         
          
```
-----------------------------------------------------------------------
**More examples:**
```{r note2} 
```
-----------------------------------------------------------------------
**No per group 44, worst:0.2, best:0.35**  
```{r note4} 
```
-----------------------------------------------------------------------
**No per group 26, worst:0.2, best:0.40**    
```{r note5}           

 ptw <- reactive({
   
   
         ###my function
          
pick.winner = function(nSims=1e6,  mu=c(0.12, 0.12, 0.15), nStg1=470) { 

  NumOfArms = length(mu)
  p = matrix(NA, nrow=NumOfArms, ncol=nSims) # to store simulated data
  #p <- as.data.frame(p)
  #-------------------------create data
  for (i in 1:NumOfArms)  {
    
    p[i,] = rbinom(nSims, nStg1, prob=mu[i])  #  
    
  }
 
  #-----------------------------------------------------------------------examine simulations
  # A wins outright
  A1 <- (p[1, ] >  p[2, ])  & (p[1, ] >  p[3, ])  # indices where this condition is met
  Z1 <- length(A1[A1==T])/nSims

  # B wins outright
  A2 <- (p[2, ] >  p[1, ])  & (p[2, ] >  p[3, ])  # ditto
  Z2 <- length(A2[A2==T])/nSims
  
  # C wins outright
  A3 <- (p[3, ] >  p[1, ])  & (p[3, ] >  p[2, ])  # ditto
  Z3 <- length(A3[A3==T])/nSims
  
  # B and C draw and A less
  A4 <- (p[2, ] ==  p[3, ])  & (p[1, ] <  p[3, ]) 
  Z4 <- length(A4[A4==T])/nSims
  
  # A and C draw and B less
  A5 <- (p[1, ] ==  p[3, ])  & (p[2, ] <  p[1, ]) 
  Z5 <- length(A5[A5==T])/nSims
  
  # A and B draw and C less
  A6 <- (p[1, ] ==  p[2, ])  & (p[3, ] <  p[1, ]) 
  Z6 <- length(A6[A6==T])/nSims
  
  # all draw
  A7 <- (p[1, ] ==  p[2, ])  & (p[3, ] ==  p[1, ]) 
  Z7 <- length(A7[A7==T])/nSims 
  
  return(list(c(z1=Z1,z2=Z2,z3=Z3,z4=Z4,z5=Z5,z6=Z6,z7=Z7,z8=Z4/2 + Z5/2 + Z3)))
  #-----------------------------------------------------------------------
 
}
 
       
        h0         <-   (as.numeric(unlist(strsplit(input$ptw_h0,     ","))))
          s        <-   (as.numeric(unlist(strsplit(input$ptw_sims,     ","))))
      
 #------------------------------------------------------------------------------------------------------------  
       
    
        n <- seq(2,input$x_ranges_ptw[2], 1)
       
       d <- matrix(NA, ncol=8 , nrow=length(n))
       
       d <- as.data.frame(d)

#apply function to each row    

  for( i in 1: dim(d)[1]) {
           
            d[i,] <-    as.vector(unlist(pick.winner(nSims=s,  mu=h0, nStg1=n[i])))
           
        }
        
 
        
        d$n <- n
        
        names(d) <- c(

           "A wins outright",
           "B wins outright",
           "C wins outright"
  ,"B and C draw and A less"
  ,"A and C draw and B less"
  ,"A and B draw and C less"
  ,"All A B C draw"
  ,"Probability of selecting best group", "n")

         
    d <- reshape2::melt(d, id.vars="n") 
        
    
        
 return(list(

       d=d

      ))
        
        
 })
        
        
        
 
```
 
 
## Column {.tabset .tabset-fade}

### Chart x

```{r ptw plot, eval=TRUE}
 
renderPlot({
  
 p =      ptw()$d
  
 # <- p[complete.cases(p), ]
 
     
 
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_ranges_ptw[2] <= 400, 10,
           ifelse(input$x_ranges_ptw[2] > 400 & input$x_ranges_ptw[2] < 3000 ,200
                       ,  500))

  all <- ggplot(data=p,
       aes(x=n, y=value, 
           colour=variable)) +
  geom_line()  +
 
  scale_y_continuous(breaks =
                       seq(input$y_ranges_ptw[1], input$y_ranges_ptw[2], by = 0.1),
                       limits = c(input$y_ranges_ptw[1], input$y_ranges_ptw[2])) +

  scale_x_continuous(breaks =
                       seq(input$x_ranges_ptw[1], input$x_ranges_ptw[2], skips),
                       limits = c(input$x_ranges_ptw[1],  input$x_ranges_ptw[2])) +

  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +

  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Number per group', color = "Scenario")+
 
  labs(caption = paste("- No Alpha the type I assertion probability here!" )) +

  ggtitle(paste0(" Play the winner ") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
 
 })
 
          
        
        
        


 
```

### Listing

 

```{r listings ptw}


 DT::renderDataTable({

    p <-  ptw()$d
      
       namez <- names(p)
      
  d1 <-  DT::datatable(p, rownames=FALSE,
                  plugins = 'natural',
                  #options = list(
                  #  columnDefs = list(list(type = 'natural', targets = c(4,5))
                                     # )
                  )  #)
    
  
     
  
     d1<- DT::formatRound(d1,  columns="value" ,  digits=3)
      
      d1
})

 ### Column {.tabset .tabset-fade} <- this will split page in two
```



### Wiki

 
```{r ptw wiki, eval=TRUE}

 
 h5(htmlOutput("ptwwiki")) 

 
#-------------------------------------------------------------------------------------------------------


 output$ptwwiki <- renderText({  # create interactive text t1 
   
print(paste0(   
  
   tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
        
                 "Excerpts from 'False Positive Rates of Randomized Phase II Designs', Manisha Desai et. al.: "),
   
      br(),  br(), 
   
   tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
        
                 "Patients meeting the same eligibility criteria are randomized to K experimental treatments. At the conclusion of the trial, the  treatment with the best outcome is selected for further testing regardless of the magnitude of its observed advantage over the other treatments. Statistical hypothesis testing is not performed. The attraction of the selection design lies in its simplicity and moderate sample sizes consistent with traditional Phase II studies. As intended, the design provides a high probability of taking the superior treatment forward when such a treatment exists.  "),
   
           br(),  br(), 
       
          tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
                 
                 "When there is no difference among the treatments in true efficacy, a superior-looking treatment can still appear purely by chance. Unlike the  hypothesis-testing methodology, which assesses the likelihood of a false-positive finding, the selection design makes no attempt to distinguish the false positive from the true positive.") ,
  
        br(),  br(), 
       
         tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
                 
                 "It can be extremely harmful if a control arm is included. In the absence of a true treatment difference, all treatments have equal chance of being the “best looking.” The chance that an experimental treatment will appear better than the control is (K -1)/K, or 0.50 when K= 2, 0.67 when K= 3, and 0.75 when K=4.(For example, this is simply, in the case of K=4, 3 ineffective active arms and 1 control...3/4). The chance of seeing an impressive difference between an experimental treatment and the control is at least 2/K of the probabilities presented.") ,
   
    tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
        
                 " In no circumstances should a control arm be included in a selection design, because the temptation to draw error-prone inferences from it is too great. "),
     
         "."))
 
})
  
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
        
        
        
        
        
        
        
        
        
   
```
          
Wiki
====
LINKS:

[RMARKDOWN CHEATSHEET](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)
 
[SIXTY PERCENT OF THE TIME IT WORKS EVERY TIME](https://www.ejobrien.com/)
            
[PROPORTIONAL ODDS MODEL POWER CALCULATIONS FOR ORDINAL AND MIXED ORDINAL/CONTINUOUS OUTCOMES](https://www.fharrell.com/post/pop/)
            
[SAMPLE SIZE REVIEW IN A HEAD INJURY TRIAL WITH ORDERED CATEGORICAL RESPONSES, WHITHEAD 1998]( https://github.com/eamonn2014/power/blob/main/papers%20for%20git/Whitehead%201998%20sample%20size%20review%20in%20a%20head%20injury%20trial.pdf )
    
[SAMPLE SIZE CALCULATIONS FOR ORDERED CATEGORICAL RESPONSES, WHITHEAD 1998](https://github.com/eamonn2014/power/blob/main/papers%20for%20git/whitehead1993%20SAMPLE%20SIZE%20CALCULATIONS%20FOR%20ORDERED.pdf) 

[SAMPLE SIZE CALCUALTION FOR THE WILCOXON MANN WHITNEY RANK SUM TEST ADJUSTING FOR TIES, AS USED IN PASS SOFTWARE FOR NON PROPORTIONAL ODDS POWER SAMPLE SIZE/CALCULATIONS, ZHAO 2008 ](https://github.com/eamonn2014/power/blob/main/papers%20for%20git/zhao%202008%20non%20prop%20odds%20calc.pdf)

[The Sawtooth Power Function in Proportion Analyses](https://support.sas.com/documentation/cdl/en/statug/65328/HTML/default/viewer.htm#statug_power_examples02.htm)

[Plotting power curve for a two-sided binomial test in R](https://stats.stackexchange.com/questions/157465/plotting-power-curve-for-a-two-sided-binomial-test-in-r)

[Calculate Sample Size Needed to Test 1 Proportion: 1-Sample, 1-Sided](https://powerandsamplesize.com/Calculators/Test-1-Proportion/1-Sample-1-Sided)

[Play the winner paper, Randomized Phase II clinical trial January 1986Cancer Treatment Reports 69(12):1375-81](https://www.researchgate.net/publication/19087470_Randomized_Phase_II_clinical_trial)


```{r, refs}

div(p(" "))
div(p(" "))
tags$span(style="color:black", "NOTES:") 
div(p(" "))
tags$span(style="color:blue", "Countinuous endpoint using MESS::power_t_test") 
div(p(" "))
tags$span(style="color:blue", "Proportional odds using Hmisc::popower") 
div(p(" "))
tags$span(style="color:blue", "Also PO power using simulation code") 
div(p(" "))
tags$span(style="color:blue", "Non PO power by coding the equation in Zhao 2008") 
div(p(" "))
tags$span(style="color:blue", "Survival endpoint based on gsDesign::nEvents") 
div(p(" "))
tags$span(style="color:blue", "Binary endpoint using Hmisc::bpower") 
div(p(" "))
tags$span(style="color:blue", "Bernoulli endpoint using gsDesign::nBinomial1Sample") 
div(p(" "))
tags$span(style="color:blue", "Three arm trial designs using simulation") 
div(p(" "))
tags$span(style="color:blue", "Pick a winner design using simulation") 

 
    # div(p(" "))
    # tags$a(href = "https://www.ejobrien.com/", target="_blank",
    #        tags$span(style="color:blue", "[1] Sixty percent of the time it works every time <- more apps here!"),) 
    # div(p(" "))
    #   tags$a(href = "https://www.fharrell.com/post/pop/", target="_blank",
    #        tags$span(style="color:blue", "[2] Proportional Odds Model Power Calculations for Ordinal and Mixed Ordinal/Continuous Outcomes"),) 
    # div(p(" "))
    # 
    #      tags$a(href = "https://github.com/eamonn2014/power/blob/main/papers%20for%20git/bolland1998%20sampe%20size%20review%20in%20a%20head%20injury%20trial.pdf", target="_blank",
    #        tags$span(style="color:blue", "[2] SAMPLE SIZE REVIEW IN A HEAD INJURY TRIAL WITH ORDERED CATEGORICAL RESPONSES"),) 
    # div(p(" "))
    # 
    # 
    # tags$hr()                        

```