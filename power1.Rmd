---
title: "Power or sample size" 
author: 
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    social: menu
    source_code: embed
runtime: shiny
---
Binary endpoint
===

```{r global, include=FALSE}

  rm(list=ls())
  set.seed(6453)
  library(ggplot2)
  library(tidyverse)
  library(plotly)
  library(Hmisc)
  require(data.table)
  library(rms) # for PO regression
 
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # function to format decimals
  # https://stackoverflow.com/questions/3245862/format-numbers-to-significant-figures-nicely-in-r
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  formatz <- function(x){
    
    if (!is.na(x)  ) {
      
      formatC(signif(x,digits=5), digits=5,format="fg", flag="#",big.mark=",")
      
    }
    
  }
  
  formatz0 <- function(x){
    sprintf(x, fmt = '%s')  
  }
  formatz1 <- function(x){
    sprintf(x, fmt = '%#.1f')  
  }
  formatz2 <- function(x){
    sprintf(x, fmt = '%#.2f')  
  }
  formatz00 <- function(x){
    round(x,0) 
  }
  formatz3 <- function(x){
    sprintf(x, fmt = '%#.3f')  
  }
  formatz4 <- function(x){
    sprintf(x, fmt = '%#.4f')  
  }
  
 
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# start of app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```

Column {.sidebar}
-----------------------------------------------------------------------

**Enter parameters of interest separated by a comma. Up to six scenarios at once can be evaluated**

```{r tab1}

  
       
  
          splitLayout(
          textInput("p1",    div(h5(tags$span(style="color:blue", "hypothesised proportion(s) \U1D7B9 1"))),    
          value= "0.2,0.25,0.35,0.2,0.25,0.35"),)
           
          splitLayout(
          textInput("p2",    div(h5(tags$span(style="color:blue", "hypothesised proportion(s) \U1D7B9 2"))),    
          value= "0.1,0.15,0.25,0.15,0.2,0.3"),)
          
             splitLayout(
          textInput("alpha", div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= "0.05, 0.05,0.05, 0.05,0.05, 0.05"), 
                                       )
                                         
          splitLayout(
          textInput("ro",    div(h5(tags$span(style="color:blue", "ratio for unequal randomisation"))),   
          value= "1,1,1,1,1,1"),)                                
                                        
          sliderInput('x_range', 'Plot x-range', value = c(0,800),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_range', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

   
          br()
   
       
xx <- reactive({
  
    A <-   (as.numeric(unlist(strsplit(input$alpha,","))))    
    Az<-   (as.numeric(unlist(strsplit(input$p1,","))))    
    Aa<-   (as.numeric(unlist(strsplit(input$p2,","))))    
    Ab<-   (as.numeric(unlist(strsplit(input$ro,","))))    
 
    for (i in 1:6) {
          assign(paste0("A", i), A[i])
          assign(paste0("P", i), Az[i])    
          assign(paste0("P", i,"B"), Aa[i])
          assign(paste0("R", i), Ab[i])
          }

    
   sample_sizes <- seq(10, input$x_range[2], by = 10)
  # 
   #---------------------------------------------------------------
 #  trying to get n1 n2 ...etc and power to list, inefficient as I do the calc again!
    s = length(sample_sizes)
 
    res = matrix(NA, 6*s, 9)
   
    x <- s*6
      
    ind <- 1

    #-----------------------------------------------------------------------  
      
    for (j in 1:s) {
   
        for(i in 1:6) {
   
                   res[ind,1] <- i     # group 
                   res[ind,2] <- sample_sizes[j]  # total sample size
            n1 <-  res[ind,3] <- sample_sizes[j]/((eval(parse(text = paste0("R",(i)))))+1)  # n1
            n2 <-  res[ind,4] <- eval(parse(text = paste0("R",(i))))* sample_sizes[j]/
                                (eval(parse(text = paste0("R",(i))))+1)    # n2
            r <-   res[ind,5] <-(eval(parse(text = paste0("R",(i)))))      # ratio
            p1 <-  res[ind,6] <-(eval(parse(text = paste0("P",(i)))))      # p1
            p2 <-  res[ind,7] <-(eval(parse(text = paste0("P",(i),"B"))))  # p2
            a1 <-  res[ind,8] <-(eval(parse(text = paste0("A",(i)))))      # alpha
    
                  # do the calculation, feed in Hmisc function
                   res[ind,9]  <- bpower(n1 = n1, 
                                         n2 =n2, p1 = p1, p2 =  p2, alpha = a1)
      
            ind=ind+1
   
    }
  }
      
  #-----------------------------------------------------------------------    
      res<- data.frame(res)
      names(res) <- c("Index", "N","n1","n2","ratio", "P1","P2", "alpha","power")
      res <- plyr::arrange(res,Index ,N)
      res$n1 <- round(res$n1,2)
      res$n2 <- round(res$n2,2)
      res$power <- round(res$power,4)
  #-------------------------------------------------------
  # code to help with legend
 
      x <- res
    
      x$phrase <- with(x, paste(": \U1D7B9 1=",x$P1,", \U1D7B9 2=",x$P2,"\n\U1D7AA=",x$alpha, ", ratio=",x$ratio))
    
      x$r <- ifelse(x$ratio !=1,"Unequal","Equal")  
    
      x$variable <- rep(1:6, each=length(sample_sizes)) 
    
      x$variable <- x$Index
        
      x$variable <- factor(x$variable)
    
      x$tag <-  paste(as.character(x$variable),as.character(x$phrase))

  #-----------------------------------------------------------------------
    return(list(  
      
      x=x , res=res
      
     ))    

})

 
```

$\alpha$ type I assertion error $\beta$ not required


 

<!-- Column {data-width=600, height=600} -->
<!-- ----------------------------------------------------------------------- -->
<!-- ### Chart 1 -->

 
## Column {.tabset .tabset-fade}

### Chart 1

```{r tab1 plot1}

renderPlot({
  
  p =      xx()$x
  
  
 p <- p[complete.cases(p), ]
  
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_range[2] <= 1000, 50,
                ifelse(input$x_range[2] > 1000 & input$x_range[2] < 3000 ,200
                       ,  500))
   
  #https://stackoverflow.com/questions/18515588/dynamic-legend-labels-in-ggplot2
  legendlabels <- data.frame(
                    'stadtland'= unique(p$tag),
                    stringsAsFactors=FALSE)

  #-----------------------------------------------------------------------
  
  all <-ggplot(p, aes(x = N, y = power, linetype=r,
                    group=variable,
                    colour = variable)) +
  geom_line() +
    
    scale_color_manual( labels=legendlabels[['stadtland']], # c("a","b","c","d","e","f"),
                        values = c("red", "green", "blue", "purple","black","orange")) +

  scale_y_continuous(breaks = seq(input$y_range[1], input$y_range[2], by = 0.1),  
                     limits = c(input$y_range[1], input$y_range[2])) +
  scale_x_continuous(breaks = seq(input$x_range[1],input$x_range[2],skips), limits = c(input$x_range[1],input$x_range[2])) +
  theme_bw() +
  theme( 
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),
     
    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),
    
    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),
   
    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),
    
    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +
  
  
  labs(y="Power", x = 'Total Sample Size', color = "Population probabilities", linetype="Ratio" )+
  labs(caption = paste("- Ratio, see legend,less than 1, n2 is the smaller group.\n- Where the ratio of sample sizes n1/n2=x in one case and n2/n1=x in another (where x is a constant) the power of the test differs between these scenarios.\n- Uses method of Fleiss, Tytun, and Ury (but without the continuity correction) to estimate the power (or the sample size to achieve a given power) of a two-sided test for the difference in two proportions. \n- Fleiss JL, Tytun A, Ury HK (1980): A simple approximation for calculating sample sizes for comparing independent proportions. Biometrics 36:343â€“6.\n" )) +
  ggtitle(paste0("Power (or sample size) for difference in two proportions") ) 

#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
  #-----------------------------------------------------------------------
#ggplotly(all)
 })
 
```

### Listing

```{r listing}
 
 DT::renderDataTable({

    w1 <-  xx()$res
    
    DT::datatable(w1, rownames=FALSE,
                  plugins = 'natural',
                  options = list(
                    columnDefs = list(list(type = 'natural', targets = c(4,5)))
                  ))
})
  
 
``` 


Survival
====
```{r, survival}

```

Column {.sidebar}
-----------------------------------------------------------------------

**Enter parameters of interest separated by a comma. Up to six scenarios at once can be evaluated**

```{r surv1}

  
    
  
          splitLayout(
          textInput("hrs",    
                    div(h5(tags$span(style="color:blue", "hazard ratio"))),    
          value= "2,1.5,0.9,2,1.5,0.9"),)

         splitLayout(
          textInput("alphas", 
                    div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= "0.05, 0.05,0.05, 0.05,0.05, 0.05"), 
                                       )
           
          splitLayout(
          textInput("sidess",    
                    div(h5(tags$span(style="color:blue", "one or two sided"))),    
          value= "2,2,2,1,1,1"),)
                                         
          splitLayout(
          textInput("ros",    
                    div(h5(tags$span(style="color:blue", "ratio for unequal randomisation"))),   
          value= "1,2,3,1,2,3"),)                                
                                        
          sliderInput('x_ranges', 'Plot x-range', value = c(0,400),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_ranges', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

   
          br()
          
                
s1 <- reactive({
  
# function adapted from gsDesign::nEvents--------------------------------------------------------------------------

    fsupower <- function (hr = NA, alpha = 0.025,
                      beta = 0.1, ratio = 1, sided = 1, hr0 = 1, n = 0 )
{
   
      # if (sided != 1 && sided != 2) {sided=NA} # using this springs an error and crashes plot
             
        c <- sqrt(ratio)/(1 + ratio)
       
        # new code so graph is shown if a hr is missing from the 6 entries allowed
        if(is.na(hr) | is.na(sided)) { 
          
          hr=NA; pwr=NA; delta=0; se=0; sided=NA; alpha=NA; hr0=NA; ratio=NA
           
          
        } else {
        
          if (sided != 1 && sided != 2) {sided=NA}
          # my fix for the hr > 1 behavior
          
          if(hr>1) {
          delta <- -c * -(log(hr) - log(hr0))
          } else {
          delta <- -c * (log(hr) - log(hr0))
          }
        
        pwr <- stats::pnorm(-(stats::qnorm(1 - alpha/sided) - sqrt(n) * delta))#
        
        }
                pwr <- data.frame(cbind(hr = hr, n = n, alpha = alpha, 
                sided = sided, beta = 1 - pwr, Power = pwr, delta = delta, 
                ratio = ratio, hr0 = hr0, se = sqrt(1/n)/c))
        
                return(pwr)
 
    }
    
    #----------------------------------------------------------------------------------------------
    
    A <-   (as.numeric(unlist(strsplit(input$alphas,","))))    
    realHR <- Az<-   (as.numeric(unlist(strsplit(input$hrs,","))))    
    Aa<-   (as.numeric(unlist(strsplit(input$sidess,","))))    
    Ab<-   (as.numeric(unlist(strsplit(input$ros,","))))    
    

    
        for (i in 1:6) {
          assign(paste0("A", i), A[i])
          assign(paste0("P", i), realHR[i])    
          assign(paste0("P", i,"B"), Aa[i])
          assign(paste0("R", i), Ab[i])
          }


               
    sample_sizes <- seq(10, input$x_ranges[2], by = 10)
     
    A <- fsupower(hr = P1, n = sample_sizes,   alpha=A1, sided =P1B, ratio =R1)
    B <- fsupower(hr = P2, n = sample_sizes,   alpha=A2, sided =P2B, ratio =R2)
    C <- fsupower(hr = P3, n = sample_sizes,   alpha=A3, sided =P3B, ratio =R3)
    D <- fsupower(hr = P4, n = sample_sizes,   alpha=A4, sided =P4B, ratio =R4)
    E <- fsupower(hr = P5, n = sample_sizes,   alpha=A5, sided =P5B, ratio =R5)
    F <- fsupower(hr = P6, n = sample_sizes,   alpha=A6, sided =P6B, ratio =R6)

  #---------------------------------------------------------------
  
      x <- rbind(A,B,C,D, E, F)
  
      x$n2 <- x$n / (x$ratio + 1)
      x$n1 <- x$ratio * x$n2
      x$hr <- factor(x$hr)
  
      res <- x
      res <- data.frame(res)
      res$n1 <- round(res$n1,2)
      res$n2 <- round(res$n2,2)
      res$Power <- round(res$Power,4)
      
  # #-------------------------------------------------------
  # code to help with legend

      x <- res

      x$phrase <- with(x, paste(": HR=",x$hr, "ratio=",x$ratio, "\n\U1D7AA=",x$alpha, "sided=",x$sided) )
      
      x$ratio <- ifelse(x$ratio !=1,"Unequal","Equal")

      x$variable <- rep(1:6, each=length(sample_sizes))

      x$variable <- factor(x$variable)

      x$tag <-  paste(as.character(x$variable),as.character(x$phrase))

      x$ratio <- factor(x$ratio)
  #-----------------------------------------------------------------------
    return(list(  
      
      xy=x 
      
     ))    

})

```
$\alpha$ type I assertion error $\beta$ not required
 
<!-- ### Chart 1 -->

 
## Column {.tabset .tabset-fade}

### Chart 2

```{r surv plot1, eval=TRUE}


renderPlot({
  
 p =      s1()$xy
 
 
 p <- p[complete.cases(p), ]
  
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_ranges[2] <= 1000, 50,
           ifelse(input$x_ranges[2] > 1000 & input$x_ranges[2] < 3000 ,200
                       ,  500))

  #https://stackoverflow.com/questions/18515588/dynamic-legend-labels-in-ggplot2
  legendlabels <- data.frame(
                    'stadtland'= unique(p$tag),
                    stringsAsFactors=FALSE)

   p <- p[,c( "n",  "n2", "n1" , "hr", "alpha", "sided",   "Power",   "ratio", 
  "variable")]
  #-----------------------------------------------------------------------
 
  all <- ggplot(p, aes(x = n, y = Power, 
                    linetype=ratio,
                    #group = interaction(ratio, hr),
                    
                    group=variable,
                    colour = variable)) + # # had hr here initally mis match with legend
  geom_line() +

    scale_color_manual( labels=legendlabels[['stadtland']], # c("a","b","c","d","e","f"),
                        values = c("red", "green", "blue", "purple","black","orange")) +
 

  scale_y_continuous(breaks = seq(input$y_ranges[1], input$y_ranges[2], by = 0.1),
                       limits = c(input$y_ranges[1], input$y_ranges[2])) +
  scale_x_continuous(breaks = seq(input$x_ranges[1], input$x_ranges[2],skips), limits =                                    c(input$x_ranges[1], input$x_ranges[2])) +
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +


  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Total number of events', color = "Hazard ratio", linetype="Ratio" )+
 
  labs(caption = paste("- Alpha the type I assertion probability.  Note, total number of patients requires information on accrual duration and maximum follow up times. If ratio <1 n1 is the smaller group. \n- Uses method of Schoenfeld two-sided test for the ratio of two hazards. Assuming exponential hazards.\n- Schoenfeld DA. Sample-size formula for the proportional-hazards regression model. Biometrics 1983;39:499-503.\n" )) +

  ggtitle(paste0(" Power (or number of events) for hazard ratio assuming exponential hazards") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
#-----------------------------------------------------------
#ggplotly(all)
 })
 
```

### Listing


```{r listings2}


 DT::renderDataTable({

    p <-  s1()$xy
    
       p <- p[,c( "n",  "n2", "n1" , "hr", "alpha", "sided",   "Power",    "ratio" )]
    DT::datatable(p, rownames=FALSE,
                  plugins = 'natural',
                  options = list(
                    columnDefs = list(list(type = 'natural', targets = c(4,5)))
                  ))
})
  
 

``` 

Continuous
====
```{r, cont}

```

Column {.sidebar}
-----------------------------------------------------------------------


**Enter parameters of interest separated by a comma. Up to six scenarios at once can be evaluated**

```{r}

 
  
          splitLayout(
          textInput("mu1",    
                    div(h5(tags$span(style="color:blue", "\U1D77B 1, enter up to 6 pop. means"))),    
          value= "1, 1, 2, 2, 1 , 1"),)
           
          splitLayout(
          textInput("sd1",    
                    div(h5(tags$span(style="color:blue", "\U1D7BC 1, enter up to 6 pop.   SDs"))),    
          value= "3, 3, 3, 3, 3, 3"),)
          
          
                 splitLayout(
          textInput("mu2",    
                    div(h5(tags$span(style="color:blue", "\U1D77B 2, enter up to 6 pop. means"))),    
          value= "2, 2, 1, 1, 3.1, 3"),)
                 
                 
                        splitLayout(
          textInput("rsd",    
                    div(h5(tags$span(style="color:blue", "ratio for unequal \U1D7BCs "))),   
          value= "1, 1, 1, 1, 1, 1"),)                                
                        
          
                               
          
              splitLayout(
          textInput("alpham", 
                     div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
                    
                    
                    
          value= ".05, .025, .05, .025, .05, .025"), 
                                       )
              
              
                 splitLayout(
          textInput("sidem",
                    div(h5(tags$span(style="color:blue", "one or two sided alternative?"))),
          value= "2, 1, 2, 1, 2, 1"),)
              
                    splitLayout(
          textInput("rom",    
                    div(h5(tags$span(style="color:blue", "ratio for unequal randomisation"))),   
          value= "1, 1, 1, 1, 1, 1"),)     
                    
       

                                        
          sliderInput('x_rangem', 'Plot x-range', value = c(0,400),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_rangem', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

   
          br()
       
                
s2 <- reactive({
  
# function adapted from gsDesign::nEvents--------------------------------------------------------------------------
  
    A <-   (as.numeric(unlist(strsplit(input$alpham,","))))    

    Az <-   (as.numeric(unlist(strsplit(input$mu1,","))))    
    
    Aa<-   (as.numeric(unlist(strsplit(input$sd1,","))))    
    
    m2 <-   (as.numeric(unlist(strsplit(input$mu2,","))))    

    Ac<-   (as.numeric(unlist(strsplit(input$sidem,","))))

    Ab<-   (as.numeric(unlist(strsplit(input$rom,","))))    
    
    Ad<-   (as.numeric(unlist(strsplit(input$rsd,","))))    

            for (i in 1:6) {
                assign(paste0("A", i), A[i])      # alpha
                assign(paste0("M", i), Az[i])     # mu1
                assign(paste0("sd", i), Aa[i])    # sd1
                assign(paste0("M", i,"a"), m2[i]) # m2
                assign(paste0("s", i), Ac[i])     # one or two side
                assign(paste0("R", i), Ab[i])     # rand ratio
                assign(paste0("rsd", i), Ad[i])   # ratio sd
          }
    
    
    
     
    
    
    
    
    
    
    
    
     #-----------------------------------------------------------------------

    n= seq(3,input$x_rangem[2], 2)



res = matrix(NA, length(n), 10)

sofamean2 <- function(u0, u1, sd, ratio=1 , sdr=1, alternative=1, sig.level){
  
  for (i in 1: length(n)) {
    
    # trying to circumvent error on power_t_test if these inputs  are not there
    # rows with NA are dropped later
     
    if (is.na(sdr) | is.na(alternative) | is.na(sig.level) |is.na(ratio) 
      | is.na(u0)     | is.na(u1)             )
       
       {
      # delta set to NA  
      
      
      
    zz <- MESS::power_t_test(n=99, sd=1, power=NULL, ratio=1, sd.ratio=1, delta=NA, alternative="one.sided",
                             sig.level=0.05)
    
    
    zz$n[2] <- ifelse(is.na(zz$n[2]),   zz$n[1], zz$n[2])
   zz$sd[2] <- ifelse(is.na(zz$sd[2]), zz$sd[1], zz$sd[2])
   
        }  else {
    #-------------------------------------------------------------------------------
           
    side <- ifelse(alternative==1,"one.sided",
                   ifelse(alternative==2,"two.sided", NA))
    
      # circumenventing...
      if (u0-u1 < 0 & side=="one.sided") { 
        A=u0
        B=u1
        u0 = B
        u1 = A}
    
    
    zz <- MESS::power_t_test(n=n[i], sd=sd, power=NULL, ratio=ratio, sd.ratio=sdr, delta=u0-u1, alternative=side,
                             sig.level=sig.level)
    
    
    zz$n[2] <- ifelse(is.na(zz$n[2]),   zz$n[1], zz$n[2])
   zz$sd[2] <- ifelse(is.na(zz$sd[2]), zz$sd[1], zz$sd[2])
   
   
   
        }
    
    res[i,] <- c( u0, u1 , round(zz$power,3), zz$n[1], zz$n[2],zz$sd[1], zz$sd[2], zz$sig.level, zz$alternative, ratio)
    
  }
  
  
  res <- data.frame(res)
  names(res) <- c( "mu1", "mu2","power" , "n1", "n2", "sd1", "sd2","alpha","sided", "ratio")
  return(res)
  
  
}


A <-  sofamean2(u0=M1, u1=M1a, sd=sd1,   ratio=R1, sdr=rsd1, alternative=s1, sig.level =A1 )
B <-  sofamean2(u0=M2, u1=M2a, sd=sd2,   ratio=R2, sdr=rsd2, alternative=s2, sig.level =A2 )
C <-  sofamean2(u0=M3, u1=M3a, sd=sd3,   ratio=R3, sdr=rsd3, alternative=s3, sig.level =A3 )
D <-  sofamean2(u0=M4, u1=M4a, sd=sd4,   ratio=R4, sdr=rsd4, alternative=s4, sig.level =A4 )
E <-  sofamean2(u0=M5, u1=M5a, sd=sd5,   ratio=R5, sdr=rsd5, alternative=s5, sig.level =A5 )
F <-  sofamean2(u0=M6, u1=M6a, sd=sd6,   ratio=R6, sdr=rsd6, alternative=s6, sig.level =A6 )



res <- rbind(A, B , C, D, E, F) 


#----------------------------------------------------------------------------------
 
      x <- res
     
txt <- with(x,paste0(": ~\U1D728( ",mu1,", ",sd1,")", 
                                  " & ~\U1D728( ",mu2,", ",sd2,")", 
                                "\n\U1D7AA= ",alpha, " ",sided, ", ratio=",ratio))
 
      
      x$phrase <- txt
      
      x$ratio <- ifelse(x$n2==x$n1, "equal","unequal")
      
      x$n <- rowSums( cbind (as.numeric(as.character(x$n1)) ,
                             as.numeric(as.character(x$n2)), na.rm=TRUE))
      x$n <-  (as.numeric(as.character(x$n1)) +
                             as.numeric(as.character(x$n2)) )
      
      x$variable <- rep(1:6, each=length(n))

      x$variable <- factor(x$variable)

      x$tag <-  paste(as.character(x$variable),as.character(x$phrase))
      
      x$ratio <- factor(x$ratio)

      x$n <- as.numeric(as.character(x$n))
      
      x$power <- as.numeric(as.character(x$power))
 
     
  #-----------------------------------------------------------------------
    return(list(  
      
      xy=x 
      
     ))    

})
      



```
$\alpha$ type I assertion error $\beta$ not required
 
## Column {.tabset .tabset-fade}

### Chart 3

```{r surv plot2, eval=TRUE}


renderPlot({
  
 p =      s2()$xy
  
 p <- p[complete.cases(p), ]
 
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_rangem[2] <= 1000, 50,
           ifelse(input$x_rangem[2] > 1000 & input$x_rangem[2] < 3000 ,200
                       ,  500))

  #https://stackoverflow.com/questions/18515588/dynamic-legend-labels-in-ggplot2
 
  # p$tag <- substring( p$tag, 2)
 
  legendlabels <- data.frame(
                    'stadtland'= unique(p$tag),
                    stringsAsFactors=FALSE)

   p <- p[,c( "n",  "n2", "n1" , "mu1", "sd1", "mu2", "sd2",
              "alpha","sided",   "power",   "ratio", 
  "variable")]
  #-----------------------------------------------------------------------
 
  all <- ggplot(p, aes(x = n, y = power, 
                    linetype=ratio,
                    #group = interaction(ratio, hr),
                    
                    group=variable,
                    colour = variable)) + # # had hr here initally mis match with legend
  geom_line() +

    scale_color_manual( labels=legendlabels[['stadtland']], # c("a","b","c","d","e","f"),
                        values = c("red", "green", "blue", "purple","black","orange")) +

    # scale_color_manual( labels=unique(p$tag), # c("a","b","c","d","e","f"),
    #                     values = c("red", "green", "blue", "purple","black","orange")) +

  scale_y_continuous(breaks = seq(input$y_rangem[1], input$y_rangem[2], by = 0.1),
                       limits = c(input$y_rangem[1], input$y_rangem[2])) +
  scale_x_continuous(breaks = seq(input$x_rangem[1], input$x_rangem[2],skips), limits =                                    c(input$x_rangem[1], input$x_rangem[2])) +
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +


  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Total Sample Size', color = "variable", linetype="Ratio" )+
 
  labs(caption = paste("- Alpha the type I assertion probability. \n- The allocation ratio affects the second group. \n- Can use to power non-inferiority design, recall alpha 0.025 one sided is the same as 0.05 two sided. \n- Explicit non-inferioirity example (n is total sample size, CV is the shared sd : PowerTOST::power.noninf( alpha=0.025, n= 50, logscale=FALSE, theta0=0, margin =2, CV=3,design='parallel') #0.64 power" )) +

  ggtitle(paste0(" Power (or total sample size) for two means (superiority and non-inferiority) ") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
#-----------------------------------------------------------
#ggplotly(all)
 })
 
 
```

### Listing

 

```{r listings3}


 DT::renderDataTable({

    p <-  s2()$xy
    
     # p <- p[,c( "n",  "n2", "n1" , "hr", "alpha", "sided",   "Power",    "ratio" )]
      
      p$phrase <- p$tag <- NULL
    DT::datatable(p, rownames=FALSE,
                  plugins = 'natural',
                  options = list(
                    columnDefs = list(list(type = 'natural', targets = c(4,5)))
                  ))
})

``` 


Proportional odds
===

```{r, ncont}


 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# start of app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
```

Column {.sidebar}
-----------------------------------------------------------------------

**Enter cell probabilities of interest separated by a comma. Must sum to 1**

```{r tabn}
splitLayout(
          textInput("p1",    div(h5(tags$span(style="color:blue", "hyp. proportion(s) \U1D7B9 1..n"))),    
          value= "0.044, 0.019, 0.471, 0.317, 0.149"),)
           
                splitLayout(
          textInput("or", div(h5(tags$span(style="color:blue", "odds ratios"))), 
          value= "1.5,2"), 
                                       )
          
          splitLayout(
          textInput("alpha", div(h5(tags$span(style="color:blue", "\U1D7AA (type I errors)"))), 
          value= "0.025, 0.05"), 
                                       )
                                         
          splitLayout(
          textInput("Q",    div(h5(tags$span(style="color:blue", "ratios for unequal randomisation"))),   
          value= "0.5, 1"),)                                
                                        
          sliderInput('x_rangepo', 'Plot x-range', value = c(0,800),
                  min = 0, max = 5000,step=100,ticks=F)
          
          sliderInput('y_rangepo', 'Plot y-range', value = c(0,1),
                  min = 0, max = 1,step=.05,ticks=F)

   
          br()
   
          
 por <- reactive({
  
 A <-   sig.level <-   (as.numeric(unlist(strsplit(input$alpha,","))))    
        P         <-   (as.numeric(unlist(strsplit(input$p1,","))))    
        Q         <-   (as.numeric(unlist(strsplit(input$Q,"," ))))    # fraction
        or        <-   (as.numeric(unlist(strsplit(input$or,","))))   
    
 
        n= seq(2,input$x_rangepo[2], 2)

        d <- tidyr::expand_grid(or = or, alpha=A, frac =Q, n=n)
       
        d$n1 <- round(d$n*d$frac/(d$frac+1))
        
        d$n2 <- d$n - d$n1 
        
        res <-  Hmisc::popower(p=P, odds.ratio=d$or,  n1=d$n1, n2=d$n2, alpha=d$alpha)
       
        result <- cbind(unlist(res[1][[1]]), unlist(res[2][[1]]), unlist(res[3][[1]]), d)
        
        names(result)  <- c("power","eff","approx se","or",  "alpha" ,"frac","n","n1","n2" )
       
        ##--txt for legend
        x <- result
           
        txt <- with(x,paste0("OR=",or,", alpha ",alpha, ", \nratio=",frac))
 
        x$phrase <- txt
      
        x$tag <- as.character(x$phrase)
      
        result=x
 
 
    return(list(  
       
       result=result, P=P, or=or
       
      ))    
 
 })
       
 
 
 
  

```
 
 
## Column {.tabset .tabset-fade}

### Chart 4

```{r surv plot4, eval=TRUE}


renderPlot({
  
 p =      por()$result
  
 p <- p[complete.cases(p), ]
 
  #-----------------------------------------------------------------------
  skips <- ifelse(input$x_rangepo[2] <= 1000, 50,
           ifelse(input$x_rangepo[2] > 1000 & input$x_rangepo[2] < 3000 ,200
                       ,  500))

  #https://stackoverflow.com/questions/18515588/dynamic-legend-labels-in-ggplot2
 
  # p$tag <- substring( p$tag, 2)
 
  # legendlabels <- data.frame(
  #                   'stadtland'= unique(p$tag),
  #                   stringsAsFactors=FALSE)

   p <- p[,c(  "n" , "alpha",   "power",   "frac", "or" ,"tag")]
   names(p)  <-    c( "n" , "alpha",   "power",   "ratio", "variable", "tag")
  #-----------------------------------------------------------------------
   
    p <- as.data.frame(p)
   p$ratio <- factor(p$ratio)
   p$variable <- factor(p$variable)
  
  all <- ggplot(p, aes(x = n, y = power, 
                  # linetype=ratio,
                    group = interaction(ratio, variable, alpha),
                     
                    colour = tag)) + # # had hr here initally mis match with legend
  geom_line() +
 
  scale_y_continuous(breaks = 
                       seq(input$y_rangepo[1], input$y_rangepo[2], by = 0.1),
                       limits = c(input$y_rangepo[1], input$y_rangepo[2])) +
    
  scale_x_continuous(breaks =
                       seq(input$x_rangepo[1], input$x_rangepo[2], skips), 
                       limits = c(input$x_rangepo[1],  input$x_rangepo[2])) +
    
  theme_bw() +
  theme(
    plot.title=element_text(size = 19, face="bold"), plot.margin = unit(c(5.5,12,5.5,5.5), "pt"),

    legend.text=element_text(size=13),
    legend.title=element_text(size=13.5, face="bold"),
    legend.position="right",
   #https://ggplot2.tidyverse.org/articles/faq-customising.html gaps in legend
    legend.key.size = unit(1.3, "cm"),
    legend.key = element_rect(color = NA, fill = NA),

    axis.text.x  = element_text(size=12),
    axis.text.y  = element_text(size=12),
    axis.line.x = element_line(color="black"),
    axis.line.y = element_line(color="black"),

    plot.caption=element_text(hjust = 0, size = 12),
    strip.text.x = element_text(size = 16, colour = "black", angle = 0),
    axis.title.y = element_text(size = rel(2), angle = 90),
    axis.title.x = element_text(size = rel(2), angle = 0 ),

    strip.background = element_rect(colour = "black", fill = "white"),
    panel.background = element_rect(fill = 'white', colour = 'white'),
    plot.background = element_rect(fill = 'white', colour = 'white')
  ) +


  #-----------------------------------------------------------------------

  labs(y="Power", x = 'Total Sample Size', color = "variable", linetype="Ratio" )+
 
  labs(caption = paste("- Alpha the type I assertion probability. \n- The allocation ratio affects the second group. \n- Can use to power non-inferiority design, recall alpha 0.025 one sided is the same as 0.05 two sided. \n- Uses Hmisc::popower to compute the power for a two-tailed two sample comparison of ordinal outcomes under the proportional odds ordinal logistic model." )) +

  ggtitle(paste0(" Power (or total sample size) for two means (superiority and non-inferiority) ") )


#https://stackoverflow.com/questions/15059093/ggplot2-adjust-the-symbol-size-in-legends
all <- all + guides(color = guide_legend(override.aes = list(linewidth = 3 )))

print(all)
#-----------------------------------------------------------
#ggplotly(all)
 })
 
  
  
 
```

### Listing

 

```{r listings4}


 DT::renderDataTable({

    p <-  por()$result
     
      
      p$phrase <- p$tag <- NULL
      
       #p <- as.data.frame(p)
       namez <- names(p)
      
  d1 <-  DT::datatable(p, rownames=FALSE,
                  plugins = 'natural',
                  options = list(
                    columnDefs = list(list(type = 'natural', targets = c(4,5)))
                  ))
    
  
     
  
      d1<- DT::formatRound(d1,  columns=namez ,  digits=3)
      
      d1
})

```   
 

### Probabilities

 

```{r alt4}


 DT::renderDataTable({

    
    # selection of odds ratios
    or <- por()$or
    p <- por()$P
 
    res2 = matrix(NA, nrow=length(or), ncol=length(p)  +1  )
    
    # cell probabilities 
    for (i in 1:length(or)) {
      
     res2[i,] <- as.vector(c (or[i], Hmisc::pomodm(p=p, odds.ratio=or[i])))
     
    }

 
    namez <- paste0("p", 1:length(p))
    namez <- c("Odds ratio", namez)
    res2 <- as.data.frame(res2)
    names(res2) <- namez
    
 d1 <- DT::datatable(res2, rownames=FALSE,  
                      
                  plugins = 'natural',
                  options = list(#autoWidth=TRUE,
                                 pagelength=15,
                                 lengtMenu=c(20),
                                 dom="lfrtBip",
                                 buttons=c('excel')
                     
                  ))
  
  d1<- DT::formatRound(d1, columns=namez  , digits=3)
  
  d1
  
  
})  
    

```   
 

### Cum. probabilities

 

```{r alt5}
   DT::renderDataTable({

    
    # selection of odds ratios
    or <- por()$or
    p <- por()$P
  
   res2 = matrix(NA, nrow=length(or), ncol=length(p)  +1  )
    
    # cell probabilities 
    for (i in 1:length(or)) {
      
    x <-  Hmisc::pomodm(p=p, odds.ratio=or[i])
    res2[i,] <- (c(or[i],rev(cumsum(rev(x))[1: (length(p))])))
     
    }

 
    namez <- paste0("y>=", 1:length(p))
    namez <- c("Odds ratio", namez)
    res2 <- as.data.frame(res2)
    names(res2) <- namez
    
 d2 <- DT::datatable(res2, rownames=FALSE,  
                      
                  plugins = 'natural',
                  options = list(#autoWidth=TRUE,
                                 pagelength=15,
                                 lengtMenu=c(20),
                                 dom="lfrtBip",
                                 buttons=c('excel')
                     
                  ))
  
  d2<- DT::formatRound(d2, columns=namez  , digits=3)
  
  d2
  
  
  
  
})  
     


```   
 

### Means and medians

 

```{r alt6}
   DT::renderDataTable({

    
    # selection of odds ratios
    or <- por()$or
    p <- por()$P
  
   res2 = matrix(NA, nrow=length(or), ncol=3 )
    
    # means and medians
    for (i in 1:length(or)) {
    
    res2[i,] <- (c(or[i],     Hmisc::pomodm(1:length(p), p, odds.ratio=or[i])))
     
    }

  
    namez <- c("Odds ratio", "Mean","Median")
    res2 <- as.data.frame(res2)
    names(res2) <- namez
    
 d2 <- DT::datatable(res2, rownames=FALSE,  
                      
                  plugins = 'natural',
                  options = list(#autoWidth=TRUE,
                                 pagelength=15,
                                 lengtMenu=c(20),
                                 dom="lfrtBip",
                                 buttons=c('excel')
                     
                  ))
  
  d2<- DT::formatRound(d2, columns=namez  , digits=3)
  
  d2
  
  
  
  
})  
     













```   

### means and medians v odds ratio

```{r means}

# see ref 2


 k <- c(rep(0, 16), rep(1, 7), rep(2, 171), rep(3, 115), rep(4, 54))
 kp <- (c(as.vector(table(k))) / sum(table(k)))


renderPlot({
  
    #or  <- por()$or
    
    kp <- por()$P

    kx <- 1:length(kp)
 
    ors <- seq(0.2, 5, length=200)
    
    w <- pomodm(kx, kp, odds.ratio=1)
    
    z <- data.table(or=ors)
    u <- z[, as.list(w - pomodm(kx, kp, odds.ratio=or)), by=or]  # subtract
    m <- meltData(or ~ mean + median, data=u)   # is in Hmisc
    
    ggplot(m, aes(x=or, y=value, color=variable)) + geom_line() +
      geom_vline(xintercept=1, alpha=0.3) +
      guides(color=guide_legend(title='')) +
      xlab('Odds Ratio') + ylab('Difference Between Groups')


})


``` 


Proportional odds simulation
===

```{r, posim}


 
```

Column {.sidebar}
-----------------------------------------------------------------------

**Enter cell probabilities of interest separated by a comma. There will be as many intercepts as possible levels of y  minus 1. Category probabilities must sum to 1!**

```{r po sim time}
          
          splitLayout(
          textInput("p1s",    div(h5(tags$span(style="color:blue", "hyp. proportions \U1D7B9 1...n"))),    
          value= "0.044, 0.019, 0.471, 0.317, 0.149"),)
           
          splitLayout(
          textInput("ors", div(h5(tags$span(style="color:blue", "odds ratio"))), 
          value= "1.7"),  )
          
          splitLayout(
          textInput("alphas", div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= "0.05"),  )
          
          splitLayout(
          textInput("Qs",    div(h5(tags$span(style="color:blue", "ratio for unequal randomisation"))),   
          value= "0.5"),)          
          
          splitLayout(
          textInput("ss",    div(h5(tags$span(style="color:blue", "simulations"))),   
          value= "500"),)                                
                             
                
          splitLayout(
          textInput("N",    div(h5(tags$span(style="color:blue", "total sample size"))),   
          value= "512"),)        
          
    
          br()
   
          
 pors <- reactive({
  
        sig.level <-   (as.numeric(unlist(strsplit(input$alphas,","))))    
        P         <-   (as.numeric(unlist(strsplit(input$p1s   ,","))))    
        Q         <-   (as.numeric(unlist(strsplit(input$Qs    ,","))))    # fraction
        or        <-   (as.numeric(unlist(strsplit(input$ors   ,","))))   
        ss        <-   (as.numeric(unlist(strsplit(input$ss    ,","))))
        N         <-   (as.numeric(unlist(strsplit(input$N     ,","))))
#------------------------------------------------------------------------------------------------------------  
          # code to accommodating varying number of betas
        
          #n= seq(2,input$x_rangepos[2], 2)          # total sample size
          
          #--------------------------------------------------------------------------
          # manual run through 
          # n=100000
          # t.cryo <- c(rep(0, 16), rep(1, 7), rep(2, 171), rep(3, 115), rep(4, 54))
          # t.octa <- c(rep(0, 32), rep(1, 11), rep(2, 162), rep(3, 106), rep(4, 69))
          # (P <- (c(as.vector(table(t.cryo))) / sum(table(t.cryo))))
          # beta_trt <- log(1.7)
          
          #--------------------------------------------------------------------------
          # input probabilities, total sample size, trt effect on log scale , and fraction for randomisation
        
          # for future eamonn, POsim is the tmpfun function below but written to accommodate
          # varying number of categories.
       
          POsim <- function(P, n, beta_trt, Q) 
            
            {
            
              #------------------------------------------
              L <- length(P)                            # how many probabilities are there?
              tmp <- runif(n)                           # use this to determine y
              m = matrix(NA, nrow=(n), ncol=L-1 )       # use to help calculate y
              
              # treatment indicator
              trt <- sample(x=c(0, 1), size=n, prob=c(1-Q, Q) , replace=TRUE)
                
              #------------------------------------------
              # get the cum log odds p1/p2+p3+p4+p5 , p1+p2 / p3+p4+p5 ....
              lo <- c()
              for ( i in 1:L) {lo[i] = (log(  sum(P[1:i]) / (1 - sum(P[1:i]) ) ) )}
              lo <- lo*-1
              
              #-------------------------------------------
              
              for (i in 1:L-1) {  
                
                  assign(paste0("beta_level", i), lo[i])  # assign lo to beta_level objects
                
                  trt.eff <- beta_trt*trt                 # randomized trt. effect assigned
                  
                  #  work out log odds for each level + trt
                  eta   <- trt.eff + eval(parse(text = paste0("beta_level",i))) 
                    
                  probs <- exp(eta)/(1+exp(eta)) # work out probs
                  
                  assign(paste0("p", i), probs)  # assign to objects
                   
                  m[,i] <- (tmp  < eval(parse(text = paste0("p",i))))*1  # capture y
                  
              } 
           
               y <-   apply(m,1,sum) 
              
               f1 <- lrm(y~trt) 
               
               f1$stats[5]
          }
           
           # manual run through ------------------------------------------------------
           # sims =500
           # n=402
           # t.cryo <- c(rep(0, 16), rep(1, 7), rep(2, 171), rep(3, 115), rep(4, 54))
           # (P <- (c(as.vector(table(t.cryo))) / sum(table(t.cryo))))
           # 
           # out <- replicate(sims, POsim(P =P, n=N, beta_trt=log(1/1.7) ) )
           # mean( out <= 0.05 )  # PASS 
           # -------------------------------------------------------------------------
           
           # execute the function
           #--------------------------------------------------------------------------
           out <- replicate(ss, POsim(P =P, n=N, beta_trt=log(or), Q=Q ) )
           pvalue <- mean( out <= sig.level )  #  power
           #-------------------------------------------------------------------------
      
           # 2 Now harrell's function, collect the power
           n2 <- round( N * Q )
           n1 <- N - n2 
           harrell <-  Hmisc::popower(p=P, odds.ratio=or, n1=n1, n2=n2,  alpha=sig.level )[[1]]
    
           
     return(list(  
       
       pvalue = pvalue, harrell=harrell
       
      ))    
 
 })
       
           
           
           
           
       
#------------------------------------------------------------------------------------------------------------        
        
        
# standard superiority
# tmpfun <- function(n, beta_trt, beta_level4, beta_level3, beta_level2, beta_level1) {
#   
#   trt <- sample(c(0, 1), n, replace=TRUE) # trt indicator
#   
#   trt.eff <- beta_trt*trt 
#   
#   
#   eta4    <- trt.eff +beta_level4  
#   eta3    <- trt.eff +beta_level3         
#   eta2    <- trt.eff +beta_level2         
#   eta1    <- trt.eff +beta_level1     
#   
#   p1 <- exp(eta1)/(1+exp(eta1))    
#   p2 <- exp(eta2)/(1+exp(eta2))   
#   p3 <- exp(eta3)/(1+exp(eta3))   
#   p4 <- exp(eta4)/(1+exp(eta4))   
#   
#   tmp <- runif(n)
#   y <- (tmp < p1) + (tmp < p2) + (tmp < p3)  + (tmp < p4)
#   f1 <- lrm(y~trt) 
#   f1$stats[5]
# }
# 
# # set up 
# t.cryo <- c(rep(0, 16), rep(1, 7), rep(2, 171), rep(3, 115), rep(4, 54))
# t.octa <- c(rep(0, 32), rep(1, 11), rep(2, 162), rep(3, 106), rep(4, 69))
# (p <- (c(as.vector(table(t.cryo))) / sum(table(t.cryo))))
# 
# # get the cum log odds p1/p2+p3+p4+p5 , p1+p2 / p3+p4+p5 ....
# lo <- c()
# for ( i in 1:5) {lo[i] = (log(  sum(p[1:i]) / (1 - sum(p[1:i]) ) ) )}
# lo <- lo*-1
# 
# #----------------------------------------------------
# # execute1.7 , I validated these using PASS 
# out <- replicate(500, tmpfun(402,log(1.7),  lo[1], lo[2], lo[3], lo[4]))
 

```
 
 
## Column {.tabset .tabset-fade}

### Power

```{r  plot6, eval=TRUE}

#  DT::renderDataTable({
# 
#       p <-  pors()$pvalue
#       h  <- pors()$harrell
#       
#       p <-  as.data.frame(cbind(h ,p))
#       namez <- c("Hmisc::popower","Simulated power")
#       names(p) <- namez
#     
#       d1 <-  DT::datatable(p, rownames=FALSE,
#                       plugins = 'natural',
#                       )
#     
#       d1 <- DT::formatRound(d1,  columns=namez ,  digits=5)
#       
#       d1
# })

 
#-------------------------------------------------------------------------------------------------------

h5(htmlOutput("intro1")) 
br()
 

#-------------------------------------------------------------------------------------------------------

 output$intro1 <- renderText({  # create interactive text t1

 
    print(paste0(
      
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
               
               "Power for proportional odds model")   ,
      br(), 
         br(), 
          br(), 
      
      
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",  pors()$harrell,
               
               "this is power from Hmisc:popower ") ,
     
        br(), 
     
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",  pors()$pvalue,
               
               "this is power from simulation ") ,
     
      br(),  br(), 
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
               
               "Proportional odds (PO) and ordinal logisitc regression are synonyms. Frank Harrell's Hmisc::lrm function is used in this app, the parameterisation is pr[Y >= j|X]. When Y=0,1, the parameterisation is exactly that for binary logistic regression. This may be different to other PO model functions. For example, the PASS power sample software's procedure 'Tests for Two Ordered Categorical Variables' uses the opposite parameterisation, so an odds ratio of say 3/2 in this app is equivalent to and odds ratio of 2/3 with that software and vice versa. If we consider higher categories as worse outcomes, the default 1.7 odds ratio, indicates that the treatment relative to  placebo in truth is associated with a 1.70 times increased odds of having a more serious outcome.") ,

   br(),  br(), 
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
               
               "For the randomisation allocation, 0.5 is equal to 1:1 randomisation. If 0.33 is entered for unequal randomisation, 33% of patients are randomised to the treatment arm.") ,
      
   br(),  br(), 
       tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
               
               "With the PO model, every category can even have only 1 entry. The WRST test works best when there are no ties (P values are more accurate). The PO model also works well if there are a huge numbers of ties. For example, even if 97% of data were at y=0, clumped at zero, this is no issue. The model handles ceiling effects and floor effects. If y is bimodal or trimodal, no problem again. The Hmisc package has the functions lrm (discrete ordnial and can handle 200 intercepts) and orm (more for continuious data and can handle 8,000 intercepts speedily and has other link functions also) for ordinal regression. ") ,
   
   
       "."))

 })
# proportional eâ†µect of treatment across the scale of the ordinal outcome







``` 


Three arm trial (continuous and binary)
===

```{r, threearm}


 
```

Column {.sidebar}
-----------------------------------------------------------------------

**Enter 3 means or proportions and select 1 or 2 for binary or continuous**

```{r threearm1}
          
          splitLayout(
          textInput("link",    div(h5(tags$span(style="color:blue", "1 for binary 2 for countinuous"))),
          value= "1"),)

          splitLayout(
          textInput("mus",    div(h5(tags$span(style="color:blue", "3 means or 3 proportions "))),    
          value= ".9,.8,.7"),)
           
          splitLayout(
          textInput("sds", div(h5(tags$span(style="color:blue", "3 SDs (ignored for binary data"))), 
          value= "5.22,5.22,5.22"),  )
          
          splitLayout(
          textInput("alphas", div(h5(tags$span(style="color:blue", "\U1D7AA (type I error)"))), 
          value= "0.05"),  )
     
          splitLayout(
          textInput("ss",    div(h5(tags$span(style="color:blue", "no. of simulations"))),   
          value= "500"),)                                
                             
                
          splitLayout(
          textInput("N",    div(h5(tags$span(style="color:blue", "sample size per arm"))),   
          value= "40"),)        
          
    
          br()
   
          
 threearm <- reactive({
  
        sig.level <-   (as.numeric(unlist(strsplit(input$alphas,","))))    
        mus         <-   (as.numeric(unlist(strsplit(input$mus   ,","))))    
        link         <-   (as.numeric(unlist(strsplit(input$link    ,","))))    # fraction
        sds        <-   (as.numeric(unlist(strsplit(input$sds   ,","))))   
        ss        <-   (as.numeric(unlist(strsplit(input$ss    ,","))))
        N         <-   (as.numeric(unlist(strsplit(input$N     ,","))))
#------------------------------------------------------------------------------------------------------------  
      
      
        # from multiarm power simulations4.R
        
    three.arm <- function(u0, u1, u2, n,  sigma0, sigma1, sigma2, alpha1=0.05 ,  nSims=sims , out.var=1 )
{
  
  P1 <- P2 <- P3 <- P4 <- P5 <- P6 <- 0 # counter        
          
  if (out.var %in% 1)    {    
          
  sigma0=sqrt(u0*(1-u0)) #placebo se
  sigma1=sqrt(u1*(1-u1)) #arm1 se
  sigma2=sqrt(u2*(1-u2)) #arm2 se
    
  } 
  
  for (i in 1:nSims) {
    
    y0=rnorm(1, u0, sigma0/sqrt(n)) # responses
    y1=rnorm(1, u1, sigma1/sqrt(n))
    y2=rnorm(1, u2, sigma2/sqrt(n))
    
    z1=(y0-y1)/sqrt(sigma1^2/n+sigma0^2/n) # arm1 v placebo z value
    z2=(y0-y2)/sqrt(sigma2^2/n+sigma0^2/n) # arm2 v placebo z value
    z3=(y2-y1)/sqrt(sigma2^2/n+sigma1^2/n) # arm2 v arm1 z value
    
    t1=2*(1-pnorm(z1))  # 2 sided p-valu
    t2=2*(1-pnorm(z2))
    t3=2*(1-pnorm(z3))
    
    #power
    if(t1<=alpha1/2){P1=P1+1/nSims} # bonferroni
    if(t2<=alpha1/2){P2=P2+1/nSims} # bonferroni
    if(t2<=alpha1/2 & t1<=alpha1/2){P3=P3+1/nSims}  # bonferroni
    if(t2<=alpha1/3 & t1<=alpha1/3 & t3<=alpha1/3){P4=P4+1/nSims}  # bonferroni 3
    if(t2<=alpha1/3 | t1<=alpha1/3 | t3<=alpha1/3){P5=P5+1/nSims}  # bonferroni 3
    if(t2<=alpha1/2 | t1<=alpha1/2){P6=P6+1/nSims}  # bonferroni
  }
  
  return (c( 
    "power arm1 v placebo being signif. ",   formatz4(P1),
    "power arm2 v placebo being signif. ",formatz4(P2),
    "power for both arms v placebo being signif.", formatz4(P3) ,
    "conjunctive (power to reject all null hypoth)", formatz4(P4) ,
    "disjunctive (power to reject at least one null hypothesis) ", formatz4(P5) ,
    "power for at least one arm signif. v placebo ", formatz4(P6) 
  ))
}

##  
        
 x<-  three.arm(u0=mus[1], u1=mus[2], u2=mus[3], sigma0=sds[1], sigma1=sds[2], sigma2=sds[3], 
             n=N, alpha=sig.level, out.var=link, nSims=ss)     
        
        
     return(list(  
       
       AA =  paste(x[1],x[2]),
       BB =  paste(x[3],x[4]),
       
       CC =  paste(x[5],x[6]),
       DD =  paste(x[7],x[8]),
       
       EE =  paste(x[9],x[10]),
       FF =  paste(x[11],x[12])
       
      ))    
 
 })
       
 
 
```
 
 
## Column {.tabset .tabset-fade}

### Chart 7

```{r threearmo, eval=TRUE}
 
 
h5(htmlOutput("intro2")) 
br()
 

#-------------------------------------------------------------------------------------------------------

 output$intro2 <- renderText({  # create interactive text t1

 
    print(paste0(
      
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$AA,
               
               "Power")   ,
      
         br(), 
          br(), 
      
           tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$BB,
               
              "Power")   ,
     
        br(),  br(),
  
     tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$CC,
               
              "Power")   ,
     
        br(),  br(),
   
     
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$DD,
               
              "Power")   ,
     
        br(),  br(),
     
          
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$EE,
               
              "Power")   ,
     
        br(),  br(),
     
     
          
       tags$span(style="color:blue;font-weight:bold;font-size: 20px;", threearm()$FF,
               
              "Power")   ,
     
        br(),  br(),
     

       "."))

 })
 
 




 
```
 
          
References
====
```{r, refs}
 
    div(p(" "))
    tags$a(href = "https://www.ejobrien.com/", target="_blank",
           tags$span(style="color:blue", "[1] Sixty percent of the time it works every time <- more apps here!"),) 
    div(p(" "))
      tags$a(href = "https://www.fharrell.com/post/pop/", target="_blank",
           tags$span(style="color:blue", "[2] Proportional Odds Model Power Calculations for Ordinal and Mixed Ordinal/Continuous Outcomes"),) 
    div(p(" "))
    
    
    
    
    tags$hr()                        

```